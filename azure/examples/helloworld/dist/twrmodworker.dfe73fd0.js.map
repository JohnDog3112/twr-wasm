{"mappings":"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","sources":["../../lib-js/twrmodworker.js","../../source/twr-wasm-ts/twrmodworker.ts","../../lib-js/twrcanvas.js","../../source/twr-wasm-ts/twrcanvas.ts","../../lib-js/twrcircular.js","../../source/twr-wasm-ts/twrcircular.ts","../../lib-js/twrsignal.js","../../source/twr-wasm-ts/twrsignal.ts","../../lib-js/twrdiv.js","../../source/twr-wasm-ts/twrdiv.ts","../../lib-js/twrdebug.js","../../source/twr-wasm-ts/twrdebug.ts","../../lib-js/twrmodbase.js","../../source/twr-wasm-ts/twrmodbase.ts","../../lib-js/twrfloat.js","../../source/twr-wasm-ts/twrfloat.ts","../../lib-js/twrwaitingcalls.js","../../source/twr-wasm-ts/twrwaitingcalls.ts","../../lib-js/twrdate.js","../../source/twr-wasm-ts/twrdate.ts"],"sourcesContent":["// this script is the WebWorker thead used by class twrWasmAsyncModule\nimport { twrCanvasProxy } from \"./twrcanvas.js\";\nimport { twrDivProxy } from \"./twrdiv.js\";\nimport { twrDebugLogProxy } from \"./twrdebug.js\";\nimport { twrWasmModuleBase } from \"./twrmodbase.js\";\nimport { twrWaitingCallsProxy } from \"./twrwaitingcalls.js\";\nlet mod;\nonmessage = function (e) {\n    //console.log('twrworker.js: message received from main script: '+e.data);\n    if (e.data[0] == 'startup') {\n        const params = e.data[1];\n        //console.log(\"Worker startup params:\",params);\n        mod = new twrWasmModuleInWorker(params.modParams, params.modWorkerParams);\n        mod.loadWasm(params.urlToLoad).then(() => {\n            postMessage([\"startupOkay\"]);\n        }).catch((ex) => {\n            console.log(\".catch: \", ex);\n            postMessage([\"startupFail\", ex]);\n        });\n    }\n    else if (e.data[0] == 'callC') {\n        mod.callCImpl(e.data[1], e.data[2]).then((rc) => {\n            postMessage([\"callCOkay\", rc]);\n        }).catch(e => {\n            console.log(\"exception in callC twrworker.js\\n\");\n            console.log(e);\n            postMessage([\"callCFail\", e]);\n        });\n    }\n    else {\n        console.log(\"twrworker.js: unknown message: \" + e);\n    }\n};\n// ************************************************************************\nclass twrWasmModuleInWorker extends twrWasmModuleBase {\n    malloc;\n    modParams;\n    constructor(modParams, modInWorkerParams) {\n        super();\n        this.isWorker = true;\n        this.malloc = (size) => { throw new Error(\"error - un-init malloc called\"); };\n        this.modParams = modParams;\n        //console.log(\"twrWasmModuleInWorker: \", modInWorkerParams.canvasProxyParams)\n        const canvasProxy = new twrCanvasProxy(modInWorkerParams.canvasProxyParams, this);\n        const divProxy = new twrDivProxy(modInWorkerParams.divProxyParams);\n        const waitingCallsProxy = new twrWaitingCallsProxy(modInWorkerParams.waitingCallsProxyParams);\n        this.modParams.imports = {\n            twrDebugLog: twrDebugLogProxy,\n            twrSleep: waitingCallsProxy.sleep.bind(waitingCallsProxy),\n            twrTime: waitingCallsProxy.time.bind(waitingCallsProxy),\n            twrDivCharOut: divProxy.charOut.bind(divProxy),\n            twrDivCharIn: divProxy.charIn.bind(divProxy),\n            twrCanvasCharIn: canvasProxy.charIn.bind(canvasProxy),\n            twrCanvasInkey: canvasProxy.inkey.bind(canvasProxy),\n            twrCanvasGetProp: canvasProxy.getProp.bind(canvasProxy),\n            twrCanvasDrawSeq: canvasProxy.drawSeq.bind(canvasProxy),\n            twrSin: Math.sin,\n            twrCos: Math.cos,\n            twrTan: Math.tan,\n            twrFAbs: Math.abs,\n            twrACos: Math.acos,\n            twrASin: Math.asin,\n            twrATan: Math.atan,\n            twrExp: Math.exp,\n            twrFloor: Math.floor,\n            twrCeil: Math.ceil,\n            twrFMod: function (x, y) { return x % y; },\n            twrLog: Math.log,\n            twrPow: Math.pow,\n            twrSqrt: Math.sqrt,\n            twrTrunc: Math.trunc,\n            twrDtoa: this.floatUtil.dtoa.bind(this.floatUtil),\n            twrToFixed: this.floatUtil.toFixed.bind(this.floatUtil),\n            twrToExponential: this.floatUtil.toExponential.bind(this.floatUtil),\n            twrAtod: this.floatUtil.atod.bind(this.floatUtil),\n            twrFcvtS: this.floatUtil.fcvtS.bind(this.floatUtil)\n        };\n    }\n}\n//# sourceMappingURL=twrmodworker.js.map","// this script is the WebWorker thead used by class twrWasmAsyncModule\r\n\r\nimport {twrCanvasProxy} from \"./twrcanvas.js\";\r\nimport {twrDivProxy} from \"./twrdiv.js\";\r\nimport {twrDebugLogProxy} from \"./twrdebug.js\";\r\nimport {TAsyncModStartupMsg} from \"./twrmodasync.js\"\r\nimport {twrWasmModuleBase, IModInWorkerParams, IModParams} from \"./twrmodbase.js\"\r\nimport {twrWaitingCallsProxy} from \"./twrwaitingcalls.js\";\r\n\r\nlet mod:twrWasmModuleInWorker;\r\n\r\nonmessage = function(e) {\r\n    //console.log('twrworker.js: message received from main script: '+e.data);\r\n\r\n    if (e.data[0]=='startup') {\r\n        const params:TAsyncModStartupMsg=e.data[1];\r\n        //console.log(\"Worker startup params:\",params);\r\n        mod=new twrWasmModuleInWorker(params.modParams, params.modWorkerParams);\r\n\r\n        mod.loadWasm(params.urlToLoad).then( ()=> {\r\n            postMessage([\"startupOkay\"]);\r\n        }).catch( (ex)=> {\r\n            console.log(\".catch: \", ex);\r\n            postMessage([\"startupFail\", ex]);\r\n        });\r\n    }\r\n    else if (e.data[0]=='callC') {\r\n         mod.callCImpl(e.data[1], e.data[2]).then( (rc)=> {\r\n            postMessage([\"callCOkay\", rc]);\r\n        }).catch(e => {\r\n            console.log(\"exception in callC twrworker.js\\n\");\r\n            console.log(e);\r\n            postMessage([\"callCFail\", e]);\r\n        });\r\n    }\r\n    else {\r\n        console.log(\"twrworker.js: unknown message: \"+e);\r\n    }\r\n}\r\n\r\n\r\n// ************************************************************************\r\n\r\nclass twrWasmModuleInWorker extends twrWasmModuleBase {\r\n\tmalloc:(size:number)=>Promise<number>;\r\n    modParams: IModParams;\r\n\r\n\r\n    constructor(modParams:IModParams, modInWorkerParams:IModInWorkerParams) {\r\n        super();\r\n        this.isWorker=true;\r\n        this.malloc=(size:number)=>{throw new Error(\"error - un-init malloc called\")};\r\n        this.modParams=modParams;\r\n\r\n        //console.log(\"twrWasmModuleInWorker: \", modInWorkerParams.canvasProxyParams)\r\n        const canvasProxy = new twrCanvasProxy(modInWorkerParams.canvasProxyParams, this);\r\n        const divProxy = new twrDivProxy(modInWorkerParams.divProxyParams);\r\n        const waitingCallsProxy = new twrWaitingCallsProxy(modInWorkerParams.waitingCallsProxyParams);\r\n\r\n        this.modParams.imports={\r\n            twrDebugLog:twrDebugLogProxy,\r\n            twrSleep:waitingCallsProxy.sleep.bind(waitingCallsProxy),\r\n            twrTime:waitingCallsProxy.time.bind(waitingCallsProxy),\r\n\r\n            twrDivCharOut:divProxy.charOut.bind(divProxy), \r\n            twrDivCharIn:divProxy.charIn.bind(divProxy),      \r\n\r\n            twrCanvasCharIn:canvasProxy.charIn.bind(canvasProxy),\r\n            twrCanvasInkey:canvasProxy.inkey.bind(canvasProxy),\r\n            twrCanvasGetProp:canvasProxy.getProp.bind(canvasProxy),\r\n            twrCanvasDrawSeq:canvasProxy.drawSeq.bind(canvasProxy),\r\n\r\n\t\t\ttwrSin:Math.sin,\r\n\t\t\ttwrCos:Math.cos,\r\n\t\t\ttwrTan: Math.tan,\r\n\t\t\ttwrFAbs: Math.abs,\r\n\t\t\ttwrACos: Math.acos,\r\n\t\t\ttwrASin: Math.asin,\r\n\t\t\ttwrATan: Math.atan,\r\n\t\t\ttwrExp: Math.exp,\r\n\t\t\ttwrFloor: Math.floor,\r\n\t\t\ttwrCeil: Math.ceil,\r\n\t\t\ttwrFMod: function(x:number, y:number) {return x%y},\r\n\t\t\ttwrLog: Math.log,\r\n\t\t\ttwrPow: Math.pow,\r\n\t\t\ttwrSqrt: Math.sqrt,\r\n\t\t\ttwrTrunc: Math.trunc,\r\n\r\n            twrDtoa: this.floatUtil.dtoa.bind(this.floatUtil),\r\n\t\t\ttwrToFixed: this.floatUtil.toFixed.bind(this.floatUtil),\r\n\t\t\ttwrToExponential: this.floatUtil.toExponential.bind(this.floatUtil),\r\n\t\t\ttwrAtod: this.floatUtil.atod.bind(this.floatUtil),\r\n\t\t\ttwrFcvtS: this.floatUtil.fcvtS.bind(this.floatUtil)\r\n            \r\n        }\r\n   }\r\n}\r\n\r\n\r\n\r\n\r\n","import { twrSharedCircularBuffer } from \"./twrcircular.js\";\nimport { twrSignal } from \"./twrsignal.js\";\nvar D2DType;\n(function (D2DType) {\n    D2DType[D2DType[\"D2D_FILLRECT\"] = 1] = \"D2D_FILLRECT\";\n    D2DType[D2DType[\"D2D_FILLCHAR\"] = 5] = \"D2D_FILLCHAR\";\n    D2DType[D2DType[\"D2D_SETLINEWIDTH\"] = 10] = \"D2D_SETLINEWIDTH\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLERGBA\"] = 11] = \"D2D_SETFILLSTYLERGBA\";\n    D2DType[D2DType[\"D2D_SETFONT\"] = 12] = \"D2D_SETFONT\";\n    D2DType[D2DType[\"D2D_BEGINPATH\"] = 13] = \"D2D_BEGINPATH\";\n    D2DType[D2DType[\"D2D_MOVETO\"] = 14] = \"D2D_MOVETO\";\n    D2DType[D2DType[\"D2D_LINETO\"] = 15] = \"D2D_LINETO\";\n    D2DType[D2DType[\"D2D_FILL\"] = 16] = \"D2D_FILL\";\n    D2DType[D2DType[\"D2D_STROKE\"] = 17] = \"D2D_STROKE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLERGBA\"] = 18] = \"D2D_SETSTROKESTYLERGBA\";\n    D2DType[D2DType[\"D2D_ARC\"] = 19] = \"D2D_ARC\";\n    D2DType[D2DType[\"D2D_STROKERECT\"] = 20] = \"D2D_STROKERECT\";\n    D2DType[D2DType[\"D2D_FILLTEXT\"] = 21] = \"D2D_FILLTEXT\";\n    D2DType[D2DType[\"D2D_IMAGEDATA\"] = 22] = \"D2D_IMAGEDATA\";\n    D2DType[D2DType[\"D2D_PUTIMAGEDATA\"] = 23] = \"D2D_PUTIMAGEDATA\";\n    D2DType[D2DType[\"D2D_BEZIERTO\"] = 24] = \"D2D_BEZIERTO\";\n    D2DType[D2DType[\"D2D_MEASURETEXT\"] = 25] = \"D2D_MEASURETEXT\";\n    D2DType[D2DType[\"D2D_SAVE\"] = 26] = \"D2D_SAVE\";\n    D2DType[D2DType[\"D2D_RESTORE\"] = 27] = \"D2D_RESTORE\";\n    D2DType[D2DType[\"D2D_CREATERADIALGRADIENT\"] = 28] = \"D2D_CREATERADIALGRADIENT\";\n    D2DType[D2DType[\"D2D_SETCOLORSTOP\"] = 29] = \"D2D_SETCOLORSTOP\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLEGRADIENT\"] = 30] = \"D2D_SETFILLSTYLEGRADIENT\";\n    D2DType[D2DType[\"D2D_RELEASEID\"] = 31] = \"D2D_RELEASEID\";\n    D2DType[D2DType[\"D2D_CREATELINEARGRADIENT\"] = 32] = \"D2D_CREATELINEARGRADIENT\";\n    D2DType[D2DType[\"D2D_SETFILLSTYLE\"] = 33] = \"D2D_SETFILLSTYLE\";\n    D2DType[D2DType[\"D2D_SETSTROKESTYLE\"] = 34] = \"D2D_SETSTROKESTYLE\";\n})(D2DType || (D2DType = {}));\nexport class twrCanvas {\n    ctx;\n    props = { charWidth: 0, charHeight: 0, foreColor: 0, backColor: 0, widthInChars: 0, heightInChars: 0, canvasHeight: 0, canvasWidth: 0 };\n    owner;\n    cmdCompleteSignal;\n    canvasKeys;\n    precomputedObjects;\n    constructor(element, modParams, modbase) {\n        const { forecolor, backcolor, fontsize, isd2dcanvas: isd2dcanvas } = modParams;\n        this.owner = modbase;\n        this.props.widthInChars = modParams.windim[0];\n        this.props.heightInChars = modParams.windim[1];\n        if (!this.owner.isWasmModule) {\n            this.cmdCompleteSignal = new twrSignal();\n            this.canvasKeys = new twrSharedCircularBuffer(); // tsconfig, lib must be set to 2017 or higher\n        }\n        this.precomputedObjects = {};\n        if (element) {\n            if (!element.getContext)\n                throw new Error(\"attempted to create new twrCanvas with an element that is not a valid HTMLCanvasElement\");\n            let c = element.getContext(\"2d\");\n            if (!c)\n                throw new Error(\"canvas 2D context not found in twrCanvasConstructor\");\n            c.font = fontsize.toString() + \"px Courier New\";\n            c.textBaseline = \"top\";\n            const sampleText = \"          \";\n            const tm = c.measureText(sampleText);\n            this.props.charWidth = Math.ceil(tm.width / sampleText.length); // ceil rounds up (eg .9 -> 1)\n            let fM = c.measureText(\"X\");\n            this.props.charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\n            if (!isd2dcanvas) {\n                element.width = this.props.charWidth * this.props.widthInChars;\n                element.height = this.props.charHeight * this.props.heightInChars;\n            }\n            this.props.canvasHeight = element.height;\n            this.props.canvasWidth = element.width;\n            //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\n            // reset after dims changed.  Not sure if ctx is needed to reset, but others do\n            let c2 = element.getContext(\"2d\");\n            if (!c2)\n                throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\n            this.ctx = c2;\n            this.ctx.font = fontsize.toString() + \"px Courier New\";\n            this.ctx.textBaseline = \"top\";\n            c2.fillStyle = backcolor;\n            this.props.backColor = Number(\"0x\" + c2.fillStyle.slice(1));\n            c2.fillStyle = forecolor;\n            this.props.foreColor = Number(\"0x\" + c2.fillStyle.slice(1));\n        }\n        //console.log(\"Create New twrCanvas: \",this.isValid(), element, this);\n        //console.log(\"twrCanvas.constructor props: \", this.props);\n    }\n    isValid() {\n        return !!this.ctx;\n    }\n    getProxyParams() {\n        if (!this.cmdCompleteSignal || !this.canvasKeys)\n            throw new Error(\"internal error in getProxyParams.\");\n        return [this.props, this.cmdCompleteSignal.sharedArray, this.canvasKeys.sharedArray];\n    }\n    getProp(pn) {\n        if (!this.isValid())\n            console.log(\"internal error - getProp called on invalid twrCanvas\");\n        const propName = this.owner.getString(pn);\n        //console.log(\"enter twrCanvas.getprop: \", pn, propName, this.props[propName], this.props);\n        return this.props[propName];\n    }\n    /* see draw2d.h for structs that match */\n    drawSeq(ds) {\n        //console.log(\"twr::Canvas enter drawSeq\");\n        if (!this.isValid())\n            console.log(\"internal error - drawSeq called on invalid twrCanvas\");\n        if (!this.ctx)\n            return;\n        let ins = this.owner.getLong(ds); /* ds->start */\n        const lastins = this.owner.getLong(ds + 4); /* ds->last */\n        //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\n        let next;\n        //let insCount=0;\n        while (1) {\n            //insCount++;\n            const type = this.owner.getLong(ins + 4); /* hdr->type */\n            if (0 /*type!=D2DType.D2D_FILLRECT*/) {\n                console.log(\"ins\", ins);\n                console.log(\"hdr.next\", this.owner.mem8[ins], this.owner.mem8[ins + 1], this.owner.mem8[ins + 2], this.owner.mem8[ins + 3]);\n                console.log(\"hdr.type\", this.owner.mem8[ins + 4], this.owner.mem8[ins + 5]);\n                console.log(\"next 4 bytes\", this.owner.mem8[ins + 6], this.owner.mem8[ins + 7], this.owner.mem8[ins + 8], this.owner.mem8[ins + 9]);\n                console.log(\"and 4 more \", this.owner.mem8[ins + 10], this.owner.mem8[ins + 11], this.owner.mem8[ins + 12], this.owner.mem8[ins + 13]);\n                //console.log(\"ins, type, next is \", ins.toString(16), type.toString(16), next.toString(16));\n            }\n            switch (type) {\n                case D2DType.D2D_FILLRECT:\n                    {\n                        const x = this.owner.getDouble(ins + 8);\n                        const y = this.owner.getDouble(ins + 16);\n                        const w = this.owner.getDouble(ins + 24);\n                        const h = this.owner.getDouble(ins + 32);\n                        this.ctx.fillRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_STROKERECT:\n                    {\n                        const x = this.owner.getDouble(ins + 8);\n                        const y = this.owner.getDouble(ins + 16);\n                        const w = this.owner.getDouble(ins + 24);\n                        const h = this.owner.getDouble(ins + 32);\n                        this.ctx.strokeRect(x, y, w, h);\n                    }\n                    break;\n                case D2DType.D2D_FILLCHAR:\n                    {\n                        const x = this.owner.getDouble(ins + 8);\n                        const y = this.owner.getDouble(ins + 16);\n                        const c = this.owner.getShort(ins + 24);\n                        let txt = String.fromCharCode(c);\n                        this.ctx.fillText(txt, x, y);\n                    }\n                    break;\n                case D2DType.D2D_FILLTEXT:\n                    {\n                        const x = this.owner.getDouble(ins + 8);\n                        const y = this.owner.getDouble(ins + 16);\n                        const str = this.owner.getString(this.owner.getLong(ins + 24));\n                        //console.log(\"filltext \",x,y,str)\n                        this.ctx.fillText(str, x, y);\n                    }\n                    break;\n                case D2DType.D2D_MEASURETEXT:\n                    {\n                        const str = this.owner.getString(this.owner.getLong(ins + 8));\n                        const tmidx = this.owner.getLong(ins + 12);\n                        const tm = this.ctx.measureText(str);\n                        this.owner.setDouble(tmidx + 0, tm.actualBoundingBoxAscent);\n                        this.owner.setDouble(tmidx + 8, tm.actualBoundingBoxDescent);\n                        this.owner.setDouble(tmidx + 16, tm.actualBoundingBoxLeft);\n                        this.owner.setDouble(tmidx + 24, tm.actualBoundingBoxRight);\n                        this.owner.setDouble(tmidx + 32, tm.fontBoundingBoxAscent);\n                        this.owner.setDouble(tmidx + 40, tm.fontBoundingBoxDescent);\n                        this.owner.setDouble(tmidx + 48, tm.width);\n                    }\n                    break;\n                case D2DType.D2D_SETFONT:\n                    {\n                        const str = this.owner.getString(this.owner.getLong(ins + 8));\n                        this.ctx.font = str;\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLERGBA:\n                    {\n                        const color = this.owner.getLong(ins + 8);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.fillStyle = cssColor;\n                        //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\n                    }\n                    break;\n                case D2DType.D2D_SETSTROKESTYLERGBA:\n                    {\n                        const color = this.owner.getLong(ins + 8);\n                        const cssColor = \"#\" + (\"00000000\" + color.toString(16)).slice(-8);\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLE:\n                    {\n                        const cssColor = this.owner.getString(this.owner.getLong(ins + 8));\n                        this.ctx.fillStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETSTROKESTYLE:\n                    {\n                        const cssColor = this.owner.getString(this.owner.getLong(ins + 8));\n                        this.ctx.strokeStyle = cssColor;\n                    }\n                    break;\n                case D2DType.D2D_SETLINEWIDTH:\n                    {\n                        const width = this.owner.getShort(ins + 8);\n                        this.ctx.lineWidth = width;\n                        //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\n                    }\n                    break;\n                case D2DType.D2D_MOVETO:\n                    {\n                        const x = this.owner.getDouble(ins + 8);\n                        const y = this.owner.getDouble(ins + 16);\n                        this.ctx.moveTo(x, y);\n                    }\n                    break;\n                case D2DType.D2D_LINETO:\n                    {\n                        const x = this.owner.getDouble(ins + 8);\n                        const y = this.owner.getDouble(ins + 16);\n                        this.ctx.lineTo(x, y);\n                    }\n                    break;\n                case D2DType.D2D_BEZIERTO:\n                    {\n                        const cp1x = this.owner.getDouble(ins + 8);\n                        const cp1y = this.owner.getDouble(ins + 16);\n                        const cp2x = this.owner.getDouble(ins + 24);\n                        const cp2y = this.owner.getDouble(ins + 32);\n                        const x = this.owner.getDouble(ins + 40);\n                        const y = this.owner.getDouble(ins + 48);\n                        this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                    }\n                    break;\n                case D2DType.D2D_BEGINPATH:\n                    {\n                        this.ctx.beginPath();\n                    }\n                    break;\n                case D2DType.D2D_FILL:\n                    {\n                        this.ctx.fill();\n                    }\n                    break;\n                case D2DType.D2D_SAVE:\n                    {\n                        this.ctx.save();\n                    }\n                    break;\n                case D2DType.D2D_RESTORE:\n                    {\n                        this.ctx.restore();\n                    }\n                    break;\n                case D2DType.D2D_STROKE:\n                    {\n                        this.ctx.stroke();\n                    }\n                    break;\n                case D2DType.D2D_ARC:\n                    {\n                        const x = this.owner.getDouble(ins + 8);\n                        const y = this.owner.getDouble(ins + 16);\n                        const radius = this.owner.getDouble(ins + 24);\n                        const startAngle = this.owner.getDouble(ins + 32);\n                        const endAngle = this.owner.getDouble(ins + 40);\n                        const counterClockwise = (this.owner.getLong(ins + 48) != 0);\n                        this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n                    }\n                    break;\n                case D2DType.D2D_IMAGEDATA:\n                    {\n                        const start = this.owner.getLong(ins + 8);\n                        const length = this.owner.getLong(ins + 12);\n                        const width = this.owner.getLong(ins + 16);\n                        const height = this.owner.getLong(ins + 20);\n                        const id = this.owner.getLong(ins + 24);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\n                        if (this.owner.isWasmModule) {\n                            const z = new Uint8ClampedArray(this.owner.memory.buffer, start, length);\n                            this.precomputedObjects[id] = new ImageData(z, width, height);\n                        }\n                        else { // Uint8ClampedArray doesn't support shared memory\n                            this.precomputedObjects[id] = { mem8: new Uint8Array(this.owner.memory.buffer, start, length), width: width, height: height };\n                        }\n                        //console.log(\"D2D_IMAGEDATA\",start, length, width, height, this.imageData[start]);\n                    }\n                    break;\n                case D2DType.D2D_CREATERADIALGRADIENT:\n                    {\n                        const x0 = this.owner.getDouble(ins + 8);\n                        const y0 = this.owner.getDouble(ins + 16);\n                        const radius0 = this.owner.getDouble(ins + 24);\n                        const x1 = this.owner.getDouble(ins + 32);\n                        const y1 = this.owner.getDouble(ins + 40);\n                        const radius1 = this.owner.getDouble(ins + 48);\n                        const id = this.owner.getLong(ins + 56);\n                        let gradient = this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case D2DType.D2D_CREATELINEARGRADIENT:\n                    {\n                        const x0 = this.owner.getDouble(ins + 8);\n                        const y0 = this.owner.getDouble(ins + 16);\n                        const x1 = this.owner.getDouble(ins + 24);\n                        const y1 = this.owner.getDouble(ins + 32);\n                        const id = this.owner.getLong(ins + 40);\n                        let gradient = this.ctx.createLinearGradient(x0, y0, x1, y1);\n                        if (id in this.precomputedObjects)\n                            console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\n                        this.precomputedObjects[id] = gradient;\n                    }\n                    break;\n                case D2DType.D2D_SETCOLORSTOP:\n                    {\n                        const id = this.owner.getLong(ins + 8);\n                        const pos = this.owner.getLong(ins + 12);\n                        const cssColor = this.owner.getString(this.owner.getLong(ins + 16));\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        gradient.addColorStop(pos, cssColor);\n                    }\n                    break;\n                case D2DType.D2D_SETFILLSTYLEGRADIENT:\n                    {\n                        const id = this.owner.getLong(ins + 8);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \" + id);\n                        const gradient = this.precomputedObjects[id];\n                        this.ctx.fillStyle = gradient;\n                    }\n                    break;\n                case D2DType.D2D_RELEASEID:\n                    {\n                        const id = this.owner.getLong(ins + 8);\n                        if (this.precomputedObjects[id])\n                            delete this.precomputedObjects[id];\n                        else\n                            console.log(\"warning: D2D_RELEASEID with undefined ID \", id);\n                    }\n                    break;\n                case D2DType.D2D_PUTIMAGEDATA:\n                    {\n                        const id = this.owner.getLong(ins + 8);\n                        const dx = this.owner.getLong(ins + 12);\n                        const dy = this.owner.getLong(ins + 16);\n                        const dirtyX = this.owner.getLong(ins + 20);\n                        const dirtyY = this.owner.getLong(ins + 24);\n                        const dirtyWidth = this.owner.getLong(ins + 28);\n                        const dirtyHeight = this.owner.getLong(ins + 32);\n                        if (!(id in this.precomputedObjects))\n                            throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \" + id);\n                        //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\n                        let imgData;\n                        if (this.owner.isWasmModule) {\n                            //console.log(\"D2D_PUTIMAGEDATA isWasmModule\");\n                            imgData = this.precomputedObjects[id];\n                        }\n                        else { // Uint8ClampedArray doesn't support shared memory, so copy the memory\n                            //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\n                            const z = this.precomputedObjects[id]; // Uint8Array\n                            const ca = Uint8ClampedArray.from(z.mem8); // shallow copy\n                            imgData = new ImageData(ca, z.width, z.height);\n                        }\n                        if (dirtyWidth == 0 && dirtyHeight == 0) {\n                            this.ctx.putImageData(imgData, dx, dy);\n                        }\n                        else {\n                            this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error(\"unimplemented or unknown Sequence Type in drawSeq: \" + type);\n            }\n            next = this.owner.getLong(ins); /* hdr->next */\n            if (next == 0) {\n                if (ins != lastins)\n                    throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\n                break;\n            }\n            ins = next;\n        }\n        if (this.cmdCompleteSignal)\n            this.cmdCompleteSignal.signal();\n        //console.log(\"Canvas.drawSeq() completed  with instruction count of \", insCount);\n    }\n}\nexport class twrCanvasProxy {\n    canvasKeys;\n    drawCompleteSignal;\n    props;\n    owner;\n    constructor(params, owner) {\n        const [props, signalBuffer, canvasKeysBuffer] = params;\n        this.drawCompleteSignal = new twrSignal(signalBuffer);\n        this.canvasKeys = new twrSharedCircularBuffer(canvasKeysBuffer);\n        this.props = props;\n        this.owner = owner;\n        //console.log(\"Create New twrCanvasProxy: \",this.props)\n    }\n    charIn() {\n        //ctx.commit(); not avail in chrome\n        //postMessage([\"debug\", 'x']);\n        return this.canvasKeys.readWait(); // wait for a key, then read it\n    }\n    inkey() {\n        if (this.canvasKeys.isEmpty())\n            return 0;\n        else\n            return this.charIn();\n    }\n    getProp(pn) {\n        const propName = this.owner.getString(pn);\n        //console.log(\"enter twrCanvasProxy.getprop: \", pn, propName, this.props[propName], this.props);\n        return this.props[propName];\n    }\n    drawSeq(ds) {\n        this.drawCompleteSignal.reset();\n        postMessage([\"drawseq\", [ds]]);\n        this.drawCompleteSignal.wait();\n    }\n}\n//# sourceMappingURL=twrcanvas.js.map","import {twrWasmModuleBase, IModParams} from \"./twrmodbase.js\"\r\nimport {twrSharedCircularBuffer} from \"./twrcircular.js\";\r\nimport {twrSignal} from \"./twrsignal.js\";\r\n\r\n\r\n// Canvas have a size that will be set based on the character width x height\r\n// The display size for a canvas will default to this size, but can be changed in the HTML/JS via\r\n//    canvas.style.width = \"700px\";\r\n//    canvas.style.height = \"500px\";\r\n\r\nexport interface ICanvasProps {\r\n\tcharWidth: number,\r\n\tcharHeight: number,\r\n\tforeColor: number,\r\n\tbackColor: number,\r\n    widthInChars: number,\r\n    heightInChars: number,\r\n    canvasWidth:number,\r\n    canvasHeight:number\r\n}\r\n\r\nenum D2DType {\r\n    D2D_FILLRECT=1,\r\n    D2D_FILLCHAR=5,\r\n    D2D_SETLINEWIDTH=10,\r\n    D2D_SETFILLSTYLERGBA=11,\r\n    D2D_SETFONT=12,\r\n    D2D_BEGINPATH=13,\r\n    D2D_MOVETO=14,\r\n    D2D_LINETO=15,\r\n    D2D_FILL=16,\r\n    D2D_STROKE=17,\r\n    D2D_SETSTROKESTYLERGBA=18,\r\n    D2D_ARC=19,\r\n    D2D_STROKERECT=20,\r\n    D2D_FILLTEXT=21,\r\n    D2D_IMAGEDATA=22,\r\n    D2D_PUTIMAGEDATA=23,\r\n    D2D_BEZIERTO=24,\r\n    D2D_MEASURETEXT=25,\r\n    D2D_SAVE=26,\r\n    D2D_RESTORE=27,\r\n    D2D_CREATERADIALGRADIENT=28,\r\n    D2D_SETCOLORSTOP=29,\r\n    D2D_SETFILLSTYLEGRADIENT=30,\r\n    D2D_RELEASEID=31,\r\n    D2D_CREATELINEARGRADIENT=32,\r\n    D2D_SETFILLSTYLE=33,\r\n    D2D_SETSTROKESTYLE=34\r\n\r\n}\r\n\r\nexport type TCanvasProxyParams = [ICanvasProps, SharedArrayBuffer, SharedArrayBuffer];\r\n\r\nexport interface ICanvas {\r\n    props: ICanvasProps,\r\n    charIn?: ()=>number,\r\n    inkey?: ()=>number,\r\n    getProxyParams?: ()=>TCanvasProxyParams,\r\n    drawSeq: (ds:number)=>void,\r\n }\r\n \r\nexport class twrCanvas implements ICanvas {\r\n    ctx:CanvasRenderingContext2D|undefined;\r\n    props:ICanvasProps={charWidth: 0, charHeight: 0, foreColor: 0, backColor: 0, widthInChars: 0, heightInChars: 0, canvasHeight:0, canvasWidth:0};\r\n    owner: twrWasmModuleBase;\r\n    cmdCompleteSignal?:twrSignal;\r\n    canvasKeys?: twrSharedCircularBuffer;\r\n    precomputedObjects: {  [index: number]: \r\n        (ImageData | {mem8:Uint8Array, width:number, height:number})  |\r\n        CanvasGradient\r\n    };\r\n\r\n    constructor(element:HTMLCanvasElement|null|undefined, modParams:IModParams, modbase:twrWasmModuleBase) {\r\n        const {forecolor, backcolor, fontsize, isd2dcanvas: isd2dcanvas} = modParams; \r\n        this.owner=modbase;\r\n        this.props.widthInChars=modParams.windim[0];\r\n        this.props.heightInChars=modParams.windim[1];\r\n\r\n        if (!this.owner.isWasmModule) {\r\n            this.cmdCompleteSignal=new twrSignal();\r\n            this.canvasKeys = new twrSharedCircularBuffer();  // tsconfig, lib must be set to 2017 or higher\r\n        }\r\n\r\n        this.precomputedObjects={};\r\n  \r\n        if (element) {\r\n            if (!element.getContext) throw new Error(\"attempted to create new twrCanvas with an element that is not a valid HTMLCanvasElement\");\r\n            let c=element.getContext(\"2d\");\r\n            if (!c) throw new Error(\"canvas 2D context not found in twrCanvasConstructor\");\r\n\r\n            c.font = fontsize.toString()+\"px Courier New\";\r\n            c.textBaseline=\"top\";\r\n            const sampleText=\"          \";\r\n            const tm=c.measureText(sampleText);\r\n            this.props.charWidth=Math.ceil(tm.width / sampleText.length);   // ceil rounds up (eg .9 -> 1)\r\n            let fM = c.measureText(\"X\"); \r\n            this.props.charHeight = Math.ceil(fM.fontBoundingBoxAscent + fM.fontBoundingBoxDescent);\r\n\r\n            if (!isd2dcanvas) {\r\n                element.width=this.props.charWidth*this.props.widthInChars;\r\n                element.height=this.props.charHeight*this.props.heightInChars;\r\n            }\r\n\r\n            this.props.canvasHeight=element.height;\r\n            this.props.canvasWidth=element.width;\r\n            //console.log(\"this.props.canvasHeight, this.props.canvasWidth\",this.props.canvasHeight,this.props.canvasWidth);\r\n\r\n            // reset after dims changed.  Not sure if ctx is needed to reset, but others do\r\n            let c2=element.getContext(\"2d\");\r\n            if (!c2) throw new Error(\"canvas 2D context not found in twrCanvas.constructor (2nd time)\");\r\n            this.ctx=c2;\r\n            this.ctx.font = fontsize.toString()+\"px Courier New\";\r\n            this.ctx.textBaseline=\"top\";\r\n\r\n            c2.fillStyle=backcolor;\r\n            this.props.backColor=Number(\"0x\"+c2.fillStyle.slice(1));\r\n\r\n            c2.fillStyle=forecolor;\r\n            this.props.foreColor=Number(\"0x\"+c2.fillStyle.slice(1));\r\n\r\n        }\r\n\r\n        //console.log(\"Create New twrCanvas: \",this.isValid(), element, this);\r\n\r\n        //console.log(\"twrCanvas.constructor props: \", this.props);\r\n   }\r\n\r\n    isValid() {\r\n        return !!this.ctx;\r\n    }\r\n\r\n    getProxyParams() : TCanvasProxyParams {\r\n        if (!this.cmdCompleteSignal || !this.canvasKeys) throw new Error(\"internal error in getProxyParams.\");\r\n        return [this.props, this.cmdCompleteSignal.sharedArray, this.canvasKeys.sharedArray];\r\n    }\r\n\r\n    getProp(pn:number): number {\r\n        if (!this.isValid()) console.log(\"internal error - getProp called on invalid twrCanvas\");\r\n        const propName=this.owner.getString(pn) as keyof ICanvasProps;\r\n        //console.log(\"enter twrCanvas.getprop: \", pn, propName, this.props[propName], this.props);\r\n        return this.props[propName];\r\n    }\r\n\r\n/* see draw2d.h for structs that match */\r\n\r\n    drawSeq(ds:number) {\r\n        //console.log(\"twr::Canvas enter drawSeq\");\r\n        if (!this.isValid()) console.log(\"internal error - drawSeq called on invalid twrCanvas\");\r\n        if (!this.ctx) return;\r\n\r\n        let ins=this.owner.getLong(ds);  /* ds->start */\r\n        const lastins=this.owner.getLong(ds+4);  /* ds->last */\r\n        //console.log(\"instruction start, last \",ins.toString(16), lastins.toString(16));\r\n\r\n        let next:number;\r\n        //let insCount=0;\r\n\r\n        while (1) {\r\n\r\n            //insCount++;\r\n\r\n            const type:D2DType=this.owner.getLong(ins+4);    /* hdr->type */\r\n            if (0/*type!=D2DType.D2D_FILLRECT*/) {\r\n                console.log(\"ins\",ins)\r\n                console.log(\"hdr.next\",this.owner.mem8[ins],this.owner.mem8[ins+1],this.owner.mem8[ins+2],this.owner.mem8[ins+3]);\r\n                console.log(\"hdr.type\",this.owner.mem8[ins+4],this.owner.mem8[ins+5]);\r\n                console.log(\"next 4 bytes\", this.owner.mem8[ins+6],this.owner.mem8[ins+7],this.owner.mem8[ins+8],this.owner.mem8[ins+9]);\r\n                console.log(\"and 4 more \", this.owner.mem8[ins+10],this.owner.mem8[ins+11],this.owner.mem8[ins+12],this.owner.mem8[ins+13]);\r\n                //console.log(\"ins, type, next is \", ins.toString(16), type.toString(16), next.toString(16));\r\n             }\r\n            switch (type) {\r\n                case D2DType.D2D_FILLRECT:\r\n                {\r\n                    const x=this.owner.getDouble(ins+8);\r\n                    const y=this.owner.getDouble(ins+16);\r\n                    const w=this.owner.getDouble(ins+24);\r\n                    const h=this.owner.getDouble(ins+32);\r\n                    this.ctx.fillRect(x, y, w, h);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_STROKERECT:\r\n                {\r\n                    const x=this.owner.getDouble(ins+8);\r\n                    const y=this.owner.getDouble(ins+16);\r\n                    const w=this.owner.getDouble(ins+24);\r\n                    const h=this.owner.getDouble(ins+32);\r\n                    this.ctx.strokeRect(x, y, w, h);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_FILLCHAR:\r\n                {\r\n                    const x=this.owner.getDouble(ins+8);\r\n                    const y=this.owner.getDouble(ins+16);\r\n                    const c=this.owner.getShort(ins+24);\r\n                    let txt=String.fromCharCode(c);\r\n                    this.ctx.fillText(txt, x, y);\r\n                }\r\n                    break;\r\n\r\n                \r\n                case D2DType.D2D_FILLTEXT:\r\n                {\r\n                    const x=this.owner.getDouble(ins+8);\r\n                    const y=this.owner.getDouble(ins+16);\r\n                    const str=this.owner.getString(this.owner.getLong(ins+24));\r\n\r\n                    //console.log(\"filltext \",x,y,str)\r\n    \r\n                    this.ctx.fillText(str, x, y);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_MEASURETEXT:\r\n                {\r\n                    const str=this.owner.getString(this.owner.getLong(ins+8));\r\n                    const tmidx=this.owner.getLong(ins+12);\r\n    \r\n                    const tm=this.ctx.measureText(str);\r\n                    this.owner.setDouble(tmidx+0, tm.actualBoundingBoxAscent);\r\n                    this.owner.setDouble(tmidx+8, tm.actualBoundingBoxDescent);\r\n                    this.owner.setDouble(tmidx+16, tm.actualBoundingBoxLeft);\r\n                    this.owner.setDouble(tmidx+24, tm.actualBoundingBoxRight);\r\n                    this.owner.setDouble(tmidx+32, tm.fontBoundingBoxAscent);\r\n                    this.owner.setDouble(tmidx+40, tm.fontBoundingBoxDescent);\r\n                    this.owner.setDouble(tmidx+48, tm.width);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_SETFONT:\r\n                {\r\n                    const str=this.owner.getString(this.owner.getLong(ins+8));\r\n                    this.ctx.font=str;\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_SETFILLSTYLERGBA:\r\n                {\r\n                    const color=this.owner.getLong(ins+8); \r\n                    const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);\r\n                    this.ctx.fillStyle = cssColor;\r\n                    //console.log(\"fillstyle: \", this.ctx.fillStyle, \":\", cssColor,\":\", color)\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_SETSTROKESTYLERGBA:\r\n                {\r\n                    const color=this.owner.getLong(ins+8); \r\n                    const cssColor= \"#\"+(\"00000000\" + color.toString(16)).slice(-8);\r\n                    this.ctx.strokeStyle = cssColor;\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_SETFILLSTYLE:\r\n                {\r\n                    const cssColor= this.owner.getString(this.owner.getLong(ins+8));\r\n                    this.ctx.fillStyle = cssColor;\r\n                }\r\n                    break\r\n\r\n                case D2DType.D2D_SETSTROKESTYLE:\r\n                {\r\n                    const cssColor= this.owner.getString(this.owner.getLong(ins+8));\r\n                    this.ctx.strokeStyle = cssColor;\r\n                }\r\n                    break\r\n\r\n                case D2DType.D2D_SETLINEWIDTH:\r\n                {\r\n                    const width=this.owner.getShort(ins+8);  \r\n                    this.ctx.lineWidth=width;\r\n                    //console.log(\"twrCanvas D2D_SETLINEWIDTH: \", this.ctx.lineWidth);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_MOVETO:\r\n                {\r\n                    const x=this.owner.getDouble(ins+8);\r\n                    const y=this.owner.getDouble(ins+16);\r\n                    this.ctx.moveTo(x, y);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_LINETO:\r\n                {\r\n                    const x=this.owner.getDouble(ins+8);\r\n                    const y=this.owner.getDouble(ins+16);\r\n                    this.ctx.lineTo(x, y);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_BEZIERTO:\r\n                {\r\n                    const cp1x=this.owner.getDouble(ins+8);\r\n                    const cp1y=this.owner.getDouble(ins+16);\r\n                    const cp2x=this.owner.getDouble(ins+24);\r\n                    const cp2y=this.owner.getDouble(ins+32);\r\n                    const x=this.owner.getDouble(ins+40);\r\n                    const y=this.owner.getDouble(ins+48);\r\n                    this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_BEGINPATH:\r\n                {\r\n                    this.ctx.beginPath();\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_FILL:\r\n                {\r\n                    this.ctx.fill();\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_SAVE:\r\n                {\r\n                    this.ctx.save();\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_RESTORE:\r\n                {\r\n                    this.ctx.restore();\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_STROKE:\r\n                {\r\n                    this.ctx.stroke();\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_ARC:\r\n                {\r\n                    const x=this.owner.getDouble(ins+8);\r\n                    const y=this.owner.getDouble(ins+16);\r\n                    const radius=this.owner.getDouble(ins+24);\r\n                    const startAngle=this.owner.getDouble(ins+32);\r\n                    const endAngle=this.owner.getDouble(ins+40);\r\n                    const counterClockwise= (this.owner.getLong(ins+48)!=0);\r\n\r\n                    this.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise)\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_IMAGEDATA:\r\n                {\r\n                    const start=this.owner.getLong(ins+8);\r\n                    const length=this.owner.getLong(ins+12);\r\n                    const width=this.owner.getLong(ins+16);\r\n                    const height=this.owner.getLong(ins+20);\r\n                    const id=this.owner.getLong(ins+24);\r\n\r\n                    if ( id in this.precomputedObjects ) console.log(\"warning: D2D_IMAGEDATA ID already exists.\");\r\n\r\n                    if (this.owner.isWasmModule) {\r\n                        const z = new Uint8ClampedArray(this.owner.memory!.buffer, start, length);\r\n                        this.precomputedObjects[id]=new ImageData(z, width, height);\r\n                    }\r\n                    else {  // Uint8ClampedArray doesn't support shared memory\r\n                        this.precomputedObjects[id]={mem8: new Uint8Array(this.owner.memory!.buffer, start, length), width:width, height:height};\r\n                    }\r\n                    //console.log(\"D2D_IMAGEDATA\",start, length, width, height, this.imageData[start]);\r\n                }\r\n                    break;\r\n\r\n                case D2DType.D2D_CREATERADIALGRADIENT:\r\n                {\r\n                    const x0=this.owner.getDouble(ins+8);\r\n                    const y0=this.owner.getDouble(ins+16);\r\n                    const radius0=this.owner.getDouble(ins+24);\r\n                    const x1=this.owner.getDouble(ins+32);\r\n                    const y1=this.owner.getDouble(ins+40);\r\n                    const radius1=this.owner.getDouble(ins+48);\r\n                    const id= this.owner.getLong(ins+56);\r\n\r\n                    let gradient=this.ctx.createRadialGradient(x0, y0, radius0, x1, y1, radius1);\r\n                    if ( id in this.precomputedObjects ) console.log(\"warning: D2D_CREATERADIALGRADIENT ID already exists.\");\r\n                    this.precomputedObjects[id] = gradient;\r\n                }\r\n                    break\r\n\r\n                case D2DType.D2D_CREATELINEARGRADIENT:\r\n                    {\r\n                        const x0=this.owner.getDouble(ins+8);\r\n                        const y0=this.owner.getDouble(ins+16);\r\n                        const x1=this.owner.getDouble(ins+24);\r\n                        const y1=this.owner.getDouble(ins+32);\r\n                        const id= this.owner.getLong(ins+40);\r\n    \r\n                        let gradient=this.ctx.createLinearGradient(x0, y0, x1, y1);\r\n                        if ( id in this.precomputedObjects ) console.log(\"warning: D2D_CREATELINEARGRADIENT ID already exists.\");\r\n                        this.precomputedObjects[id] = gradient;\r\n                    }\r\n                        break\r\n\r\n                case D2DType.D2D_SETCOLORSTOP:\r\n                {\r\n                    const id = this.owner.getLong(ins+8);\r\n                    const pos=this.owner.getLong(ins+12);\r\n                    const cssColor= this.owner.getString(this.owner.getLong(ins+16));\r\n\r\n                    if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETCOLORSTOP with invalid ID: \"+id);\r\n                    const gradient=this.precomputedObjects[id] as CanvasGradient;\r\n                    gradient.addColorStop(pos, cssColor);\r\n                }\r\n                    break\r\n\r\n                case D2DType.D2D_SETFILLSTYLEGRADIENT:\r\n                {\r\n                    const id=this.owner.getLong(ins+8);\r\n                    if (!(id in this.precomputedObjects)) throw new Error(\"D2D_SETFILLSTYLEGRADIENT with invalid ID: \"+id);\r\n                    const gradient=this.precomputedObjects[id] as CanvasGradient;\r\n                    this.ctx.fillStyle=gradient;\r\n                }\r\n                    break\r\n\r\n                case D2DType.D2D_RELEASEID:\r\n                {\r\n                    const id=this.owner.getLong(ins+8);\r\n                    if (this.precomputedObjects[id])\r\n                        delete this.precomputedObjects[id];\r\n                    else\r\n                        console.log(\"warning: D2D_RELEASEID with undefined ID \",id);\r\n                }\r\n                    break\r\n\r\n                    \r\n\r\n                case D2DType.D2D_PUTIMAGEDATA:\r\n                {\r\n                    const id=this.owner.getLong(ins+8);\r\n                    const dx=this.owner.getLong(ins+12);\r\n                    const dy=this.owner.getLong(ins+16);\r\n                    const dirtyX=this.owner.getLong(ins+20);\r\n                    const dirtyY=this.owner.getLong(ins+24);\r\n                    const dirtyWidth=this.owner.getLong(ins+28);\r\n                    const dirtyHeight=this.owner.getLong(ins+32);\r\n\r\n                    if (!(id in this.precomputedObjects)) throw new Error(\"D2D_PUTIMAGEDATA with invalid ID: \"+id);\r\n\r\n                    //console.log(\"D2D_PUTIMAGEDATA\",start, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight, this.imageData[start]);\r\n\r\n                    let imgData:ImageData;\r\n                    if (this.owner.isWasmModule) {\r\n                        //console.log(\"D2D_PUTIMAGEDATA isWasmModule\");\r\n                        imgData=this.precomputedObjects[id] as ImageData;\r\n                    }\r\n                    else {  // Uint8ClampedArray doesn't support shared memory, so copy the memory\r\n                        //console.log(\"D2D_PUTIMAGEDATA wasmModuleAsync\");\r\n                        const z = this.precomputedObjects[id] as {mem8:Uint8Array, width:number, height:number}; // Uint8Array\r\n                        const ca=Uint8ClampedArray.from(z.mem8);  // shallow copy\r\n                        imgData=new ImageData(ca, z.width, z.height);\r\n                    }\r\n                    \r\n                    if (dirtyWidth==0 && dirtyHeight==0) {\r\n                        this.ctx.putImageData(imgData, dx, dy);\r\n                    }\r\n                    else {\r\n                        this.ctx.putImageData(imgData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\r\n                    }\r\n                }\r\n                    break;\r\n\r\n                default:\r\n                    throw new Error (\"unimplemented or unknown Sequence Type in drawSeq: \"+type);\r\n            }\r\n            next=this.owner.getLong(ins);  /* hdr->next */\r\n            if (next==0) {\r\n                if (ins!=lastins) throw new Error(\"assert type error in twrcanvas, ins!=lastins\");\r\n                break;\r\n            }\r\n            ins=next;\r\n        }\r\n\r\n        if (this.cmdCompleteSignal) this.cmdCompleteSignal.signal();\r\n        //console.log(\"Canvas.drawSeq() completed  with instruction count of \", insCount);\r\n    }\r\n}\r\n\r\nexport class twrCanvasProxy implements ICanvas {\r\n    canvasKeys: twrSharedCircularBuffer;\r\n    drawCompleteSignal:twrSignal;\r\n    props: ICanvasProps;\r\n    owner: twrWasmModuleBase;\r\n\r\n    constructor(params:TCanvasProxyParams, owner:twrWasmModuleBase) {\r\n        const [props, signalBuffer,  canvasKeysBuffer] = params;\r\n        this.drawCompleteSignal = new twrSignal(signalBuffer);\r\n        this.canvasKeys = new twrSharedCircularBuffer(canvasKeysBuffer);\r\n        this.props=props;\r\n        this.owner=owner;\r\n\r\n        //console.log(\"Create New twrCanvasProxy: \",this.props)\r\n\r\n    }\r\n\r\n    charIn() {  \r\n        //ctx.commit(); not avail in chrome\r\n    \r\n        //postMessage([\"debug\", 'x']);\r\n        \r\n        return this.canvasKeys.readWait();  // wait for a key, then read it\r\n    }\r\n    \r\n    inkey() {\r\n        if (this.canvasKeys.isEmpty())\r\n            return 0;\r\n        else\r\n            return this.charIn();    \r\n    }\r\n\r\n    getProp(pn:number): number {\r\n        const propName=this.owner.getString(pn) as keyof ICanvasProps;\r\n        //console.log(\"enter twrCanvasProxy.getprop: \", pn, propName, this.props[propName], this.props);\r\n        return this.props[propName];\r\n    }\r\n    \r\n    drawSeq(ds:number) {\r\n        this.drawCompleteSignal.reset();\r\n        postMessage([\"drawseq\", [ds]]);\r\n        this.drawCompleteSignal.wait();\r\n    }\r\n}\r\n","//\n// This class implements a circular buffer that the main javascript thread can write to, \n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\n// readWait() is used used when io_getc() or io_getstr() is called from a C function.\n//\nconst RDIDX = 256;\nconst WRIDX = 257;\nconst LEN = 256;\n// A single thread can read and a separate single thread can write.  With these constraints Atomic operations are not needed.\n// the first 256 array entries are the circular buffer\n// the next two are used for the read and write index\n//!!!! I am using --enable-features=SharedArrayBuffer; see the SharedArrayBuffer docs for COR issues when going to a live web server\nexport class twrSharedCircularBuffer {\n    sharedArray;\n    buf;\n    constructor(sa) {\n        if (typeof window !== 'undefined') { // this check only works if window defined (not a worker thread)\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:'))\n                throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa)\n            this.sharedArray = sa;\n        else\n            this.sharedArray = new SharedArrayBuffer(258 * 4);\n        this.buf = new Int32Array(this.sharedArray);\n        this.buf[RDIDX] = 0;\n        this.buf[WRIDX] = 0;\n    }\n    write(n) {\n        let i = this.buf[WRIDX];\n        this.buf[i] = n;\n        i++;\n        if (i == LEN)\n            i = 0;\n        this.buf[WRIDX] = i;\n        Atomics.notify(this.buf, WRIDX);\n    }\n    read() {\n        if (!this.isEmpty()) {\n            let i = this.buf[RDIDX];\n            let n = this.buf[i];\n            i++;\n            this.buf[RDIDX] = i;\n            return n;\n        }\n        else\n            return -1;\n    }\n    readWait() {\n        if (this.isEmpty()) {\n            const rdptr = this.buf[RDIDX];\n            // verifies that a shared memory location still contains a given value and if so sleeps until notified.\n            Atomics.wait(this.buf, WRIDX, rdptr);\n        }\n        return this.read();\n    }\n    isEmpty() {\n        return this.buf[RDIDX] == this.buf[WRIDX];\n    }\n}\n//# sourceMappingURL=twrcircular.js.map","//\r\n// This class implements a circular buffer that the main javascript thread can write to, \r\n// and a blocking WebWorker thread can read from.  This allows keyboard characters to be transferred from the main JS thread to a WebWorker thread.\r\n// The WebWorker can use the readWait() function to sleep, w/o participating in the normal \r\n// async callback dispatch method.  This allows a C program that is a single blocking loop to receive input from the primary javascript thread.\r\n// readWait() is used used when io_getc() or io_getstr() is called from a C function.\r\n//\r\n\r\nconst RDIDX=256;\r\nconst WRIDX=257;\r\nconst LEN=256;\r\n\r\n// A single thread can read and a separate single thread can write.  With these constraints Atomic operations are not needed.\r\n// the first 256 array entries are the circular buffer\r\n// the next two are used for the read and write index\r\n\r\n//!!!! I am using --enable-features=SharedArrayBuffer; see the SharedArrayBuffer docs for COR issues when going to a live web server\r\n\r\nexport class twrSharedCircularBuffer {\r\n\tsharedArray:SharedArrayBuffer;\r\n\tbuf:Int32Array;\r\n \r\n\tconstructor (sa?:SharedArrayBuffer) {\r\n        if (typeof window !== 'undefined') {  // this check only works if window defined (not a worker thread)\r\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:')) throw new Error(\"twrSharedCircularBuffer constructor, crossOriginIsolated=\"+crossOriginIsolated+\". See SharedArrayBuffer docs.\");\r\n        }\r\n        if (sa) this.sharedArray=sa;\r\n        else this.sharedArray=new SharedArrayBuffer(258*4);\r\n\t\tthis.buf=new Int32Array(this.sharedArray);\r\n        this.buf[RDIDX]=0;\r\n        this.buf[WRIDX]=0;\r\n\t}\r\n\r\n\twrite(n:number) {\r\n        let i=this.buf[WRIDX];\r\n        this.buf[i]=n;\r\n        i++;\r\n        if (i==LEN) i=0;\r\n        this.buf[WRIDX]=i;  \r\n        Atomics.notify(this.buf, WRIDX);   \r\n\t}\r\n\r\n\tread():number {\r\n        if (!this.isEmpty()) {\r\n            let i=this.buf[RDIDX];\r\n            let n=this.buf[i];\r\n            i++;\r\n            this.buf[RDIDX]=i;\r\n            return n;\r\n        }\r\n\t\telse\r\n            return -1;\r\n\t}\r\n\r\n    readWait():number {\r\n        if (this.isEmpty()) {\r\n            const rdptr=this.buf[RDIDX];\r\n            // verifies that a shared memory location still contains a given value and if so sleeps until notified.\r\n            Atomics.wait(this.buf, WRIDX, rdptr);\r\n        }\r\n        return this.read();\r\n\t}\r\n\r\n    isEmpty():boolean {\r\n        return this.buf[RDIDX]==this.buf[WRIDX];\r\n    }\r\n}\r\n","//\n// This class implements a simple signal/wait mechanism\n// It is used by the WebWorker thread to block/wait, and the main JS thread to signal when to unblock\n//\nvar twrSignalState;\n(function (twrSignalState) {\n    twrSignalState[twrSignalState[\"WAITING\"] = 0] = \"WAITING\";\n    twrSignalState[twrSignalState[\"SIGNALED\"] = 1] = \"SIGNALED\";\n})(twrSignalState || (twrSignalState = {}));\n;\nexport class twrSignal {\n    sharedArray;\n    buf;\n    constructor(sa) {\n        if (typeof window !== 'undefined') { // this check only works if window valid\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:'))\n                throw new Error(\"twrSignal constructor, crossOriginIsolated=\" + crossOriginIsolated + \". See SharedArrayBuffer docs.\");\n        }\n        if (sa)\n            this.sharedArray = sa;\n        else\n            this.sharedArray = new SharedArrayBuffer(4);\n        this.buf = new Int32Array(this.sharedArray);\n        this.buf[0] = twrSignalState.WAITING;\n    }\n    signal() {\n        this.buf[0] = twrSignalState.SIGNALED;\n        //console.log(\"about to signal\");\n        Atomics.notify(this.buf, 0);\n    }\n    wait() {\n        if (this.buf[0] == twrSignalState.WAITING) {\n            //console.log(\"waiting...\");\n            Atomics.wait(this.buf, 0, twrSignalState.WAITING);\n            //console.log(\"released...\");\n        }\n    }\n    isSignaled() {\n        return this.buf[0] == twrSignalState.SIGNALED;\n    }\n    reset() {\n        this.buf[0] = twrSignalState.WAITING;\n    }\n}\n//# sourceMappingURL=twrsignal.js.map","//\r\n// This class implements a simple signal/wait mechanism\r\n// It is used by the WebWorker thread to block/wait, and the main JS thread to signal when to unblock\r\n//\r\n\r\nenum twrSignalState {\r\n    WAITING=0,\r\n    SIGNALED=1\r\n};\r\n\r\nexport class twrSignal {\r\n\tsharedArray:SharedArrayBuffer;\r\n\tbuf:Int32Array;\r\n\r\n \tconstructor (sa?:SharedArrayBuffer) {\r\n        if (typeof window !== 'undefined') { // this check only works if window valid\r\n            if (!crossOriginIsolated && !(window.location.protocol === 'file:')) \r\n                throw new Error(\"twrSignal constructor, crossOriginIsolated=\"+crossOriginIsolated+\". See SharedArrayBuffer docs.\");\r\n        }\r\n        if (sa) this.sharedArray=sa;\r\n        else this.sharedArray=new SharedArrayBuffer(4);\r\n\t\tthis.buf=new Int32Array(this.sharedArray);\r\n        this.buf[0]=twrSignalState.WAITING;\r\n\t}\r\n\r\n\tsignal() {\r\n        this.buf[0]=twrSignalState.SIGNALED;  \r\n        //console.log(\"about to signal\");\r\n        Atomics.notify(this.buf, 0);   \r\n\t}\r\n\r\n    wait() {\r\n        if (this.buf[0]==twrSignalState.WAITING) {\r\n            //console.log(\"waiting...\");\r\n            Atomics.wait(this.buf, 0, twrSignalState.WAITING);\r\n            //console.log(\"released...\");\r\n\r\n        }\r\n\t}\r\n    isSignaled():boolean {\r\n        return this.buf[0]==twrSignalState.SIGNALED;\r\n    }\r\n\r\n    reset() {\r\n        this.buf[0]=twrSignalState.WAITING;\r\n    }\r\n}\r\n","import { twrSharedCircularBuffer } from \"./twrcircular.js\";\nexport class twrDiv {\n    div;\n    divKeys;\n    CURSOR = String.fromCharCode(9611); // ▋ see https://daniel-hug.github.io/characters/#k_70\n    cursorOn = false;\n    lastChar = 0;\n    extraBR = false;\n    owner;\n    constructor(element, modParams, modbase) {\n        this.div = element;\n        this.owner = modbase;\n        if (!this.owner.isWasmModule) { // twrWasmModule doesn't use shared memory\n            this.divKeys = new twrSharedCircularBuffer(); // tsconfig, lib must be set to 2017 or higher\n        }\n        if (this.div && !modParams.styleIsDefault) { // don't let default colors override divStyle\n            this.div.style.backgroundColor = modParams.backcolor;\n            this.div.style.color = modParams.forecolor;\n            this.div.style.font = modParams.fontsize.toString() + \"px arial\";\n        }\n    }\n    isValid() {\n        return !!this.div;\n    }\n    getProxyParams() {\n        if (!this.divKeys)\n            throw new Error(\"internal error in getProxyParams.\");\n        return [this.divKeys.sharedArray];\n    }\n    /*\n     * add character to div.  Supports the following control codes:\n     * any of CRLF, CR (/r), or LF(/n)  will cause a new line\n     * 0xE cursor on\n     * 0x8 backspace\n     * 0xF cursor off\n    */\n    charOut(ch) {\n        if (!this.div)\n            return;\n        //console.log(\"div::charout: \", ch);\n        if (this.extraBR) {\n            this.extraBR = false;\n            if (this.cursorOn)\n                this.div.innerHTML = this.div.innerHTML.slice(0, -1);\n            this.div.innerHTML = this.div.innerHTML.slice(0, -4);\n            if (this.cursorOn)\n                this.div.innerHTML += this.CURSOR;\n        }\n        switch (ch) {\n            case 10: // newline\n            case 13: // return\n                if (ch == 10 && this.lastChar == 13)\n                    break; // detect CR LF and treat as single new line\n                if (this.cursorOn)\n                    this.div.innerHTML = this.div.innerHTML.slice(0, -1);\n                this.div.innerHTML += \"<br><br>\"; //2nd break is a place holder for next line (fixes scroll issue at bottom)\n                this.extraBR = true;\n                if (this.cursorOn)\n                    this.div.innerHTML += this.CURSOR;\n                //element.scrollIntoView();\n                //element.scrollTop = element.scrollHeight;\n                let p = this.div.getBoundingClientRect();\n                window.scrollTo(0, p.height + 100);\n                break;\n            case 8: // backspace\n                if (this.cursorOn)\n                    this.div.innerHTML = this.div.innerHTML.slice(0, -1);\n                this.div.innerHTML = this.div.innerHTML.slice(0, -1);\n                if (this.cursorOn)\n                    this.div.innerHTML += this.CURSOR;\n                break;\n            case 0xE: // cursor on\n                if (!this.cursorOn) {\n                    this.cursorOn = true;\n                    this.div.innerHTML += this.CURSOR;\n                    this.div.focus();\n                }\n                break;\n            case 0xF: // cursor off\n                if (this.cursorOn) {\n                    this.cursorOn = false;\n                    this.div.innerHTML = this.div.innerHTML.slice(0, -1);\n                }\n                break;\n            default:\n                if (this.cursorOn)\n                    this.div.innerHTML = this.div.innerHTML.slice(0, -1);\n                this.div.innerHTML += String.fromCharCode(ch);\n                if (this.cursorOn)\n                    this.div.innerHTML += this.CURSOR;\n                break;\n        }\n        this.lastChar = ch;\n    }\n    stringOut(str) {\n        for (let i = 0; i < str.length; i++)\n            this.charOut(str.charCodeAt(i));\n    }\n}\nexport class twrDivProxy {\n    divKeys;\n    constructor(params) {\n        const [divKeysBuffer] = params;\n        this.divKeys = new twrSharedCircularBuffer(divKeysBuffer);\n    }\n    charIn() {\n        return this.divKeys.readWait(); // wait for a key, then read it\n    }\n    inkey() {\n        if (this.divKeys.isEmpty())\n            return 0;\n        else\n            return this.charIn();\n    }\n    charOut(ch) {\n        postMessage([\"divout\", ch]);\n    }\n}\n//# sourceMappingURL=twrdiv.js.map","import { twrSharedCircularBuffer } from \"./twrcircular.js\";\r\nimport { IModParams } from \"./twrmodbase.js\";\r\nimport {twrWasmModuleBase} from \"./twrmodbase.js\";\r\n\r\nexport type TDivProxyParams = [SharedArrayBuffer];\r\n\r\nexport interface IDiv {\r\n    charOut: (ds:number)=>void,\r\n    charIn?: ()=>number,\r\n    inkey?: ()=>number,\r\n    getProxyParams?: ()=>TDivProxyParams,\r\n }\r\n\r\n\r\nexport class twrDiv implements IDiv {\r\n\tdiv:HTMLDivElement|null|undefined;\r\n\tdivKeys?:twrSharedCircularBuffer;\r\n\tCURSOR=String.fromCharCode(9611);  // ▋ see https://daniel-hug.github.io/characters/#k_70\r\n\tcursorOn:boolean=false;\r\n\tlastChar:number=0;\r\n\textraBR:boolean=false;\r\n\towner:twrWasmModuleBase;\r\n\r\n    constructor(element:HTMLDivElement|null|undefined,  modParams:IModParams, modbase:twrWasmModuleBase) {\r\n\t\tthis.div=element;\r\n\t\tthis.owner=modbase;\r\n        if (!this.owner.isWasmModule) {   // twrWasmModule doesn't use shared memory\r\n\t\t\tthis.divKeys = new twrSharedCircularBuffer();  // tsconfig, lib must be set to 2017 or higher\r\n\t\t}\r\n\r\n\t\tif (this.div && !modParams.styleIsDefault) {  // don't let default colors override divStyle\r\n\t\t\tthis.div.style.backgroundColor = modParams.backcolor;\r\n\t\t\tthis.div.style.color = modParams.forecolor;\r\n\t\t\tthis.div.style.font=modParams.fontsize.toString()+\"px arial\"\r\n\t\t}\r\n   }\r\n\r\n\tisValid() {\r\n\t\treturn !!this.div;\r\n\t}\r\n\r\n    getProxyParams() : TDivProxyParams {\r\n        if (!this.divKeys) throw new Error(\"internal error in getProxyParams.\");\r\n        return [ this.divKeys.sharedArray];\r\n    }\r\n\r\n\r\n/* \r\n * add character to div.  Supports the following control codes:\r\n * any of CRLF, CR (/r), or LF(/n)  will cause a new line\r\n * 0xE cursor on \r\n * 0x8 backspace\r\n * 0xF cursor off \r\n*/\r\n\tcharOut(ch:number) {\r\n\r\n\t\tif (!this.div) return;\r\n\r\n\t\t//console.log(\"div::charout: \", ch);\r\n\r\n\t\tif (this.extraBR) {\r\n\t\t\tthis.extraBR=false;\r\n\t\t\tif (this.cursorOn) this.div.innerHTML=this.div.innerHTML.slice(0, -1);\r\n\t\t\tthis.div.innerHTML=this.div.innerHTML.slice(0, -4);\r\n\t\t\tif (this.cursorOn) this.div.innerHTML +=  this.CURSOR;\r\n\t\t}\r\n\r\n\t\tswitch (ch) {\r\n\t\t\tcase 10:  // newline\r\n\t\t\tcase 13:  // return\r\n\t\t\t\tif (ch==10 && this.lastChar==13) break;  // detect CR LF and treat as single new line\r\n\t\t\t\tif (this.cursorOn) this.div.innerHTML=this.div.innerHTML.slice(0, -1);\r\n\t\t\t\tthis.div.innerHTML +=  \"<br><br>\";   //2nd break is a place holder for next line (fixes scroll issue at bottom)\r\n\t\t\t\tthis.extraBR=true;\r\n\t\t\t\tif (this.cursorOn) this.div.innerHTML +=  this.CURSOR;\r\n\t\t\t\t//element.scrollIntoView();\r\n\t\t\t\t//element.scrollTop = element.scrollHeight;\r\n\t\t\t\tlet p = this.div.getBoundingClientRect();\r\n\t\t\t\twindow.scrollTo(0, p.height+100);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 8:  // backspace\r\n\t\t\t\tif (this.cursorOn) this.div.innerHTML=this.div.innerHTML.slice(0, -1);\r\n\t\t\t\tthis.div.innerHTML=this.div.innerHTML.slice(0, -1);\r\n\t\t\t\tif (this.cursorOn) this.div.innerHTML +=  this.CURSOR;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xE:   // cursor on\r\n\t\t\t\tif (!this.cursorOn) {\r\n\t\t\t\t\tthis.cursorOn=true;\r\n\t\t\t\t\tthis.div.innerHTML +=  this.CURSOR;\r\n\t\t\t\t\tthis.div.focus();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xF:   // cursor off\r\n\t\t\t\tif (this.cursorOn) {\r\n\t\t\t\t\tthis.cursorOn=false;\r\n\t\t\t\t\tthis.div.innerHTML=this.div.innerHTML.slice(0, -1);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tif (this.cursorOn) this.div.innerHTML=this.div.innerHTML.slice(0, -1);\r\n\t\t\t\tthis.div.innerHTML +=  String.fromCharCode(ch);\r\n\t\t\t\tif (this.cursorOn) this.div.innerHTML +=  this.CURSOR;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\tthis.lastChar=ch;\r\n\t}\r\n\r\n\tstringOut(str:string) {\r\n\t\tfor (let i=0; i < str.length; i++)\r\n\t\t\tthis.charOut(str.charCodeAt(i));\r\n\t}\r\n}\r\n\r\n\r\nexport class twrDivProxy implements IDiv {\r\n    divKeys: twrSharedCircularBuffer;\r\n\r\n    constructor(params:TDivProxyParams) {\r\n        const [divKeysBuffer] = params;\r\n        this.divKeys = new twrSharedCircularBuffer(divKeysBuffer);\r\n    }\r\n\r\n    charIn() {  \r\n        return this.divKeys.readWait();  // wait for a key, then read it\r\n    }\r\n    \r\n    inkey() {\r\n        if (this.divKeys.isEmpty())\r\n            return 0;\r\n        else\r\n            return this.charIn();    \r\n    }\r\n\r\n\tcharOut(ch:number) {\r\n\t\tpostMessage([\"divout\", ch]);\r\n\t}\r\n}\r\n\r\n","let logline = \"\";\nexport function twrDebugLogImpl(char) {\n    if (char == 10 || char == 3) { // ASCII 03 is End-of-Text, and is used here to indicate the preceding char should be printed\n        console.log(logline); // ideally without a linefeed, but there is no way to not have a LF with console.log API.\n        logline = \"\";\n    }\n    else {\n        logline = logline + String.fromCharCode(char);\n        if (logline.length >= 300) {\n            console.log(logline);\n            logline = \"\";\n        }\n    }\n}\n// ************************************************************************\n// debugLog doesn't currently wait for the message to log, it returns immediately.\n// I could move this to be in the twrWaitingCalls class\nexport function twrDebugLogProxy(ch) {\n    postMessage([\"debug\", ch]);\n}\n//# sourceMappingURL=twrdebug.js.map","\r\nlet logline=\"\";\r\nexport function twrDebugLogImpl(char:number) {\r\n\tif (char==10 || char==3) {  // ASCII 03 is End-of-Text, and is used here to indicate the preceding char should be printed\r\n\t\tconsole.log(logline);\t// ideally without a linefeed, but there is no way to not have a LF with console.log API.\r\n\t\tlogline=\"\";\r\n\t}\r\n\telse {\r\n\t\tlogline=logline+String.fromCharCode(char);\r\n\t\tif (logline.length>=300) {\r\n\t\t\tconsole.log(logline);\r\n\t\t\tlogline=\"\";\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ************************************************************************\r\n// debugLog doesn't currently wait for the message to log, it returns immediately.\r\n// I could move this to be in the twrWaitingCalls class\r\nexport function twrDebugLogProxy(ch:number) {\r\n    postMessage([\"debug\", ch]);\r\n}\r\n\r\n","import { twrFloatUtil } from \"./twrfloat.js\";\n/*********************************************************************/\n/*********************************************************************/\n/*********************************************************************/\nexport class twrWasmModuleBase {\n    memory;\n    mem8;\n    mem32;\n    memD;\n    exports;\n    isWorker = false;\n    isWasmModule; // twrWasmModule?  (eg. could be twrWasmModuleAsync, twrWasmModuleInWorker, twrWasmModuleInJSMain)\n    floatUtil;\n    constructor(isWasmModule = false) {\n        this.isWasmModule = isWasmModule; // as opposed to twrWasmModuleAsync, twrWasmModuleInWorker\n        this.mem8 = new Uint8Array(); // avoid type errors\n        this.mem32 = new Uint32Array(); // avoid type errors\n        this.memD = new Float64Array(); // avoid type errors\n        this.floatUtil = new twrFloatUtil(this);\n        //console.log(\"size of mem8 after constructor\",this.mem8.length);\n    }\n    /*********************************************************************/\n    /*********************************************************************/\n    async loadWasm(pathToLoad) {\n        //console.log(\"fileToLoad\",fileToLoad)\n        let response;\n        try {\n            response = await fetch(pathToLoad);\n        }\n        catch (err) {\n            console.log('loadWasm() failed to fetch: ' + pathToLoad);\n            throw err;\n        }\n        if (!response.ok)\n            throw new Error(\"fetch response error on file '\" + pathToLoad + \"'\\n\" + response.statusText);\n        try {\n            let wasmBytes = await response.arrayBuffer();\n            let allimports = {\n                ...this.modParams.imports\n            };\n            let instance = await WebAssembly.instantiate(wasmBytes, { env: allimports });\n            this.exports = instance.instance.exports;\n            if (!this.exports)\n                throw new Error(\"Unexpected error - undefined instance.exports\");\n            if (this.memory)\n                throw new Error(\"unexpected error -- this.memory already set\");\n            this.memory = this.exports.memory;\n            if (!this.memory)\n                throw new Error(\"Unexpected error - undefined exports.memory\");\n            this.mem8 = new Uint8Array(this.memory.buffer);\n            this.mem32 = new Uint32Array(this.memory.buffer);\n            this.memD = new Float64Array(this.memory.buffer);\n            // instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error\n            if (this.isWorker) {\n                if (this.memory.buffer instanceof ArrayBuffer)\n                    console.log(\"twrWasmModuleAsync requires shared Memory. Add wasm-ld --shared-memory --no-check-features (see docs)\");\n                postMessage([\"setmemory\", this.memory]);\n            }\n            if (this.isWasmModule) {\n                // here if twrWasmModule, twrWasmModuleAsync overrides this function\n                // instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error\n                if (!(this.memory.buffer instanceof ArrayBuffer))\n                    console.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\n            }\n            this.malloc = (size) => {\n                return new Promise(resolve => {\n                    const m = this.exports.twr_malloc;\n                    resolve(m(size));\n                });\n            };\n            this.init();\n        }\n        catch (err) {\n            console.log('WASM instantiate error: ' + err + (err.stack ? \"\\n\" + err.stack : ''));\n            throw err;\n        }\n    }\n    init() {\n        //console.log(\"loadWasm.init() enter\")\n        let p;\n        switch (this.modParams.stdio) {\n            case \"debug\":\n                p = 0;\n                break;\n            case \"div\":\n                p = 1;\n                break;\n            case \"canvas\":\n                p = 2;\n                break;\n            case \"null\":\n                p = 3;\n                break;\n            default:\n                p = 0; // debug\n        }\n        const twrInit = this.exports.twr_wasm_init;\n        //console.log(\"twrInit:\",twrInit)\n        twrInit(p, this.mem8.length);\n    }\n    /* callC takes an array where:\n    * the first entry is the name of the C function in the wasm module to call (must be exported, typically via the --export clang flag)\n    * and the next entries are a variable number of parameters to pass to the C function, of type\n    * number - converted to int32 or float64 as appropriate\n    * string - converted to a an index (ptr) into a module Memory returned via stringToMem()\n    * URL - the file contents are loaded into module Memory via urlToMem(), and two C parameters are generated - index (pointer) to the memory, and length\n    * Uint8Array - the array is loaded into module memory via uint8ArrayToMem(), and two parameters are generated - index (pointer) to the memory, and length\n    */\n    async callC(params) {\n        const cparams = await this.preCallC(params);\n        let retval = this.callCImpl(params[0], cparams);\n        this.postCallC(cparams, params);\n        return retval;\n    }\n    async callCImpl(fname, cparams = []) {\n        if (!this.exports)\n            throw new Error(\"this.exports undefined\");\n        if (!this.exports[fname])\n            throw new Error(\"callC: function '\" + fname + \"' not in export table.  Use --export wasm-ld flag.\");\n        const f = this.exports[fname];\n        let cr = f(...cparams);\n        return cr;\n    }\n    // convert an array of parameters to numbers by stuffing contents into malloc'd wasm memory\n    async preCallC(params) {\n        if (!(params.constructor === Array))\n            throw new Error(\"callC: params must be array, first arg is function name\");\n        if (params.length == 0)\n            throw new Error(\"callC: missing function name\");\n        let cparams = [];\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                    cparams[ci++] = p;\n                    break;\n                case 'string':\n                    cparams[ci++] = await this.putString(p);\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        const r = await this.fetchAndPutURL(p);\n                        cparams[ci++] = r[0]; // mem index\n                        cparams[ci++] = r[1]; // len\n                        break;\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        const r = await this.putArrayBuffer(p);\n                        cparams[ci++] = r; // mem index\n                        break;\n                    }\n                default:\n                    throw new Error(\"callC: invalid object type passed in\");\n            }\n        }\n        return cparams;\n    }\n    // free the mallocs; copy array buffer data from malloc back to arraybuffer\n    async postCallC(cparams, params) {\n        let ci = 0;\n        for (let i = 1; i < params.length; i++) {\n            const p = params[i];\n            switch (typeof p) {\n                case 'number':\n                    ci++;\n                    break;\n                case 'string':\n                    this.callCImpl('twr_free', [cparams[ci]]);\n                    ci++;\n                    break;\n                case 'object':\n                    if (p instanceof URL) {\n                        this.callCImpl('twr_free', [cparams[ci]]);\n                        ci = ci + 2;\n                        break;\n                    }\n                    else if (p instanceof ArrayBuffer) {\n                        let u8 = new Uint8Array(p);\n                        for (let j = 0; j < u8.length; j++)\n                            u8[j] = this.mem8[cparams[ci] + j]; // mod.mem8 is a Uint8Array view of the module's Web Assembly Memory\n                        this.callCImpl('twr_free', [cparams[ci]]);\n                        ci++;\n                        break;\n                    }\n                    else\n                        throw new Error(\"postCallC: internal error A\");\n                default:\n                    throw new Error(\"postCallC: internal error B\");\n            }\n        }\n        return cparams;\n    }\n    /*********************************************************************/\n    /*********************************************************************/\n    // copy a string into existing buffer in the webassembly module memory\n    copyString(buffer, buffer_size, sin) {\n        let i;\n        for (i = 0; i < sin.length && i < buffer_size - 1; i++)\n            this.mem8[buffer + i] = sin.charCodeAt(i);\n        this.mem8[buffer + i] = 0;\n    }\n    // allocate and copy a string into the webassembly module memory\n    async putString(sin) {\n        let strIndex = await this.malloc(sin.length);\n        this.copyString(strIndex, sin.length, sin);\n        return strIndex;\n    }\n    async putU8(u8a) {\n        let dest = await this.malloc(u8a.length);\n        for (let i = 0; i < u8a.length; i++)\n            this.mem8[dest + i] = u8a[i];\n        return dest;\n    }\n    async putArrayBuffer(ab) {\n        const u8 = new Uint8Array(ab);\n        return this.putU8(u8);\n    }\n    // given a url, load its contents, and stuff into wasm memory similar to Unint8Array\n    async fetchAndPutURL(fnin) {\n        if (!(typeof fnin === 'object' && fnin instanceof URL))\n            throw new Error(\"fetchAndPutURL param must be URL\");\n        try {\n            let response = await fetch(fnin);\n            let buffer = await response.arrayBuffer();\n            let src = new Uint8Array(buffer);\n            let dest = await this.putU8(src);\n            return [dest, src.length];\n        }\n        catch (err) {\n            console.log('fetchAndPutURL Error. URL: ' + fnin + '\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\n            throw err;\n        }\n    }\n    getLong(idx) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"getLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length)\n            throw new Error(\"invalid index passed to getLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        const long = this.mem32[idx32];\n        return long;\n    }\n    setLong(idx, value) {\n        const idx32 = Math.floor(idx / 4);\n        if (idx32 * 4 != idx)\n            throw new Error(\"setLong passed non long aligned address\");\n        if (idx32 < 0 || idx32 >= this.mem32.length)\n            throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\n        this.mem32[idx32] = value;\n    }\n    getDouble(idx) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx)\n            throw new Error(\"getLong passed non Float64 aligned address\");\n        const long = this.memD[idx64];\n        return long;\n    }\n    setDouble(idx, value) {\n        const idx64 = Math.floor(idx / 8);\n        if (idx64 * 8 != idx)\n            throw new Error(\"setDouble passed non Float64 aligned address\");\n        this.memD[idx64] = value;\n    }\n    getShort(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getShort: \" + idx);\n        const short = this.mem8[idx] + this.mem8[idx + 1] * 256;\n        return short;\n    }\n    // get a string out of module memory\n    // null terminated, up until max of (optional) len\n    getString(strIndex, len) {\n        let sout = \"\";\n        let i = 0;\n        while (this.mem8[strIndex + i] && (len === undefined ? true : i < len) && (strIndex + i) < this.mem8.length) {\n            sout = sout + String.fromCharCode(this.mem8[strIndex + i]);\n            i++;\n        }\n        return sout;\n    }\n    // get a byte array out of module memory when passed in index to [size, dataptr]\n    getU8Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getU8: \" + idx);\n        const rv = new Uint32Array((this.mem8.slice(idx, idx + 8)).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= (this.mem8.length))\n            throw new Error(\"invalid idx.dataptr passed to getU8\");\n        if (size < 0 || size > (this.mem8.length - dataptr))\n            throw new Error(\"invalid idx.size passed to  getU8\");\n        const u8 = this.mem8.slice(dataptr, dataptr + size);\n        return u8;\n    }\n    // get a int32 array out of module memory when passed in index to [size, dataptr]\n    getU32Arr(idx) {\n        if (idx < 0 || idx >= this.mem8.length)\n            throw new Error(\"invalid index passed to getU32: \" + idx);\n        const rv = new Uint32Array((this.mem8.slice(idx, idx + 8)).buffer);\n        let size = rv[0];\n        let dataptr = rv[1];\n        if (dataptr < 0 || dataptr >= (this.mem8.length))\n            throw new Error(\"invalid idx.dataptr passed to getU32\");\n        if (size < 0 || size > (this.mem8.length - dataptr))\n            throw new Error(\"invalid idx.size passed to  getU32\");\n        if (size % 4 != 0)\n            throw new Error(\"idx.size is not an integer number of 32 bit words\");\n        const u32 = new Uint32Array((this.mem8.slice(dataptr, dataptr + size)).buffer);\n        return u32;\n    }\n}\n//# sourceMappingURL=twrmodbase.js.map","\r\nimport {TCanvasProxyParams} from \"./twrcanvas.js\"\r\nimport {TDivProxyParams} from \"./twrdiv.js\";\r\nimport {TWaitingCallsProxyParams} from \"./twrwaitingcalls.js\"\r\nimport {twrDebugLogImpl} from \"./twrdebug.js\";\r\nimport {twrFloatUtil} from \"./twrfloat.js\";\r\n\r\n\r\nexport type TStdioVals=\"div\"|\"canvas\"|\"null\"|\"debug\";\r\n\r\nexport interface IModOpts {\r\n\tstdio?:TStdioVals, \r\n\twindim?:[number, number],\r\n\tforecolor?:string,\r\n\tbackcolor?:string,\r\n\tfontsize?:number,\r\n\tisd2dcanvas?:boolean,\r\n\timports?:{},\r\n}\r\n\r\nexport interface IModParams {\r\n\tstdio:TStdioVals, \r\n\twindim:[number, number],\r\n\tforecolor:string,\r\n\tbackcolor:string,\r\n\tfontsize:number,\r\n\tstyleIsDefault: boolean\r\n\tisd2dcanvas:boolean,\r\n\timports:{[index:string]:Function},\r\n}\r\n\r\nexport interface IModInWorkerParams {\r\n\tdivProxyParams:TDivProxyParams,\r\n\tcanvasProxyParams:TCanvasProxyParams,\r\n\twaitingCallsProxyParams:TWaitingCallsProxyParams,\r\n}\r\n\r\n/*********************************************************************/\r\n/*********************************************************************/\r\n/*********************************************************************/\r\n\r\nexport abstract class twrWasmModuleBase {\r\n\tmemory?:WebAssembly.Memory;\r\n\tmem8:Uint8Array;\r\n\tmem32:Uint32Array;\r\n\tmemD:Float64Array;\r\n\tabstract malloc:(size:number)=>Promise<number>;\r\n\tabstract modParams:IModParams;\r\n\texports?:WebAssembly.Exports;\r\n\tisWorker=false;\r\n\tisWasmModule:boolean;  // twrWasmModule?  (eg. could be twrWasmModuleAsync, twrWasmModuleInWorker, twrWasmModuleInJSMain)\r\n\tfloatUtil:twrFloatUtil;\r\n\r\n\tconstructor(isWasmModule=false) {\r\n\t\tthis.isWasmModule=isWasmModule;  // as opposed to twrWasmModuleAsync, twrWasmModuleInWorker\r\n\t\tthis.mem8=new Uint8Array();  \t// avoid type errors\r\n\t\tthis.mem32=new Uint32Array();  // avoid type errors\r\n\t\tthis.memD=new Float64Array();  // avoid type errors\r\n\t\tthis.floatUtil=new twrFloatUtil(this);\r\n\t\t//console.log(\"size of mem8 after constructor\",this.mem8.length);\r\n\t}\r\n\r\n\t/*********************************************************************/\r\n\t/*********************************************************************/\r\n\r\n\tasync loadWasm(pathToLoad:string) {\r\n\t\t//console.log(\"fileToLoad\",fileToLoad)\r\n\r\n\t\tlet response;\r\n\t\ttry {\r\n\t\t\tresponse=await fetch(pathToLoad);\r\n\t\t} catch(err:any) {\r\n\t\t\tconsole.log('loadWasm() failed to fetch: '+pathToLoad);\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t\t\r\n\t\tif (!response.ok) throw new Error(\"fetch response error on file '\"+pathToLoad+\"'\\n\"+response.statusText);\r\n\r\n\t\ttry {\r\n\t\t\tlet wasmBytes = await response.arrayBuffer();\r\n\r\n\t\t\tlet allimports:WebAssembly.ModuleImports = { \r\n\t\t\t\t...this.modParams.imports\r\n\t\t\t};\r\n\r\n\t\t\tlet instance = await WebAssembly.instantiate(wasmBytes, {env: allimports});\r\n\r\n\t\t\tthis.exports=instance.instance.exports;\r\n\t\t\tif (!this.exports) throw new Error(\"Unexpected error - undefined instance.exports\");\r\n\r\n\t\t\tif (this.memory) throw new Error (\"unexpected error -- this.memory already set\");\r\n\t\t\tthis.memory=this.exports.memory as WebAssembly.Memory;\r\n\t\t\tif (!this.memory) throw new Error(\"Unexpected error - undefined exports.memory\");\r\n\t\t\tthis.mem8 = new Uint8Array(this.memory.buffer);\r\n\t\t\tthis.mem32 = new Uint32Array(this.memory.buffer);\r\n\t\t\tthis.memD = new Float64Array(this.memory.buffer);\r\n\t\t\t// instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error\r\n\t\t\tif (this.isWorker) {\r\n\t\t\t\tif (this.memory.buffer instanceof ArrayBuffer)\r\n\t\t\t\t\tconsole.log(\"twrWasmModuleAsync requires shared Memory. Add wasm-ld --shared-memory --no-check-features (see docs)\");\r\n\t\t\t\t\r\n\t\t\t\tpostMessage([\"setmemory\",this.memory]);\r\n\t\t\t}\r\n\t\t\tif (this.isWasmModule) {\r\n\t\t\t\t// here if twrWasmModule, twrWasmModuleAsync overrides this function\r\n\t\t\t\t// instanceof SharedArrayBuffer doesn't work when crossOriginIsolated not enable, and will cause a runtime error\r\n\t\t\t\tif (!(this.memory.buffer instanceof ArrayBuffer))\r\n\t\t\t\t\tconsole.log(\"twrWasmModule does not require shared Memory. Okay to remove wasm-ld --shared-memory --no-check-features\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.malloc=(size:number)=>{\r\n\t\t\t\treturn new Promise(resolve => {\r\n\t\t\t\t\tconst m=this.exports!.twr_malloc as (size:number)=>number;\r\n\t\t\t\t\tresolve(m(size));\r\n\t\t\t\t});\r\n\t\t   };\r\n\r\n\t\t\tthis.init();\r\n\r\n\t\t} catch(err:any) {\r\n\t\t\tconsole.log('WASM instantiate error: ' + err + (err.stack ? \"\\n\" + err.stack : ''));\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate init() {\r\n\t\t//console.log(\"loadWasm.init() enter\")\r\n\t\t\tlet p:number;\r\n\t\t\tswitch (this.modParams.stdio) {\r\n\t\t\t\tcase \"debug\":\r\n\t\t\t\t\tp=0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"div\":\r\n\t\t\t\t\tp=1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"canvas\":\r\n\t\t\t\t\tp=2;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"null\":\r\n\t\t\t\t\tp=3;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tp=0;  // debug\r\n\t\t\t}\r\n\r\n\t\t\tconst twrInit=this.exports!.twr_wasm_init as CallableFunction;\r\n\t\t\t//console.log(\"twrInit:\",twrInit)\r\n\t\t\ttwrInit(p, this.mem8.length);\r\n\t}\r\n\r\n\t/* callC takes an array where:\r\n\t* the first entry is the name of the C function in the wasm module to call (must be exported, typically via the --export clang flag)\r\n\t* and the next entries are a variable number of parameters to pass to the C function, of type\r\n\t* number - converted to int32 or float64 as appropriate\r\n\t* string - converted to a an index (ptr) into a module Memory returned via stringToMem()\r\n\t* URL - the file contents are loaded into module Memory via urlToMem(), and two C parameters are generated - index (pointer) to the memory, and length\r\n\t* Uint8Array - the array is loaded into module memory via uint8ArrayToMem(), and two parameters are generated - index (pointer) to the memory, and length\r\n    */\r\n\r\n\tasync callC(params:[string, ...(string|number|ArrayBuffer|URL)[]]) {\r\n\t\tconst cparams=await this.preCallC(params);\r\n\t\tlet retval = this.callCImpl(params[0], cparams);\r\n\t\tthis.postCallC(cparams, params);\r\n\t\treturn retval;\r\n\t}\r\n\r\n\tasync callCImpl(fname:string, cparams:number[]=[]) {\r\n\t\tif (!this.exports) throw new Error(\"this.exports undefined\");\r\n\t\tif (!this.exports[fname]) throw new Error(\"callC: function '\"+fname+\"' not in export table.  Use --export wasm-ld flag.\");\r\n\r\n\t\tconst f = this.exports[fname] as CallableFunction;\r\n\t\tlet cr=f(...cparams);\r\n\r\n\t\treturn cr;\r\n\t}\r\n\r\n\t// convert an array of parameters to numbers by stuffing contents into malloc'd wasm memory\r\n\tasync preCallC(params:[string, ...(string|number|ArrayBuffer|URL)[]]) {\r\n\r\n\t\tif (!(params.constructor === Array)) throw new Error (\"callC: params must be array, first arg is function name\");\r\n\t\tif (params.length==0) throw new Error(\"callC: missing function name\");\r\n\r\n\t\tlet cparams:number[]=[];\r\n\t\tlet ci=0;\r\n\t\tfor (let i=1; i < params.length; i++) {\r\n\t\t\tconst p=params[i];\r\n\t\t\tswitch (typeof p) {\r\n\t\t\t\tcase 'number':\r\n\t\t\t\t\tcparams[ci++]=p;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\tcparams[ci++]=await this.putString(p);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'object':\r\n\t\t\t\t\tif (p instanceof URL) {\r\n\t\t\t\t\t\tconst r=await this.fetchAndPutURL(p);\r\n\t\t\t\t\t\tcparams[ci++]=r[0];  // mem index\r\n\t\t\t\t\t\tcparams[ci++]=r[1];   // len\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p instanceof ArrayBuffer) {\r\n\t\t\t\t\t\tconst r=await this.putArrayBuffer(p);\r\n\t\t\t\t\t\tcparams[ci++]=r;  // mem index\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error (\"callC: invalid object type passed in\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cparams;\r\n\t}\r\n\r\n\t// free the mallocs; copy array buffer data from malloc back to arraybuffer\r\n\tasync postCallC(cparams:number[], params:[string, ...(string|number|ArrayBuffer|URL)[]]) {\r\n\r\n\t\tlet ci=0;\r\n\t\tfor (let i=1; i < params.length; i++) {\r\n\t\t\tconst p=params[i];\r\n\t\t\tswitch (typeof p) {\r\n\t\t\t\tcase 'number':\r\n\t\t\t\t\tci++;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\tthis.callCImpl('twr_free',[cparams[ci]])\r\n\t\t\t\t\tci++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase 'object':\r\n\t\t\t\t\tif (p instanceof URL) {\r\n\t\t\t\t\t\tthis.callCImpl('twr_free',[cparams[ci]])\r\n\t\t\t\t\t\tci=ci+2;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p instanceof ArrayBuffer) {\r\n\t\t\t\t\t\tlet u8=new Uint8Array(p);\r\n\t\t\t\t\t\tfor (let j=0; j<u8.length; j++)\r\n\t\t\t\t\t\t\tu8[j]=this.mem8[cparams[ci]+j];   // mod.mem8 is a Uint8Array view of the module's Web Assembly Memory\r\n\t\t\t\t\t\tthis.callCImpl('twr_free',[cparams[ci]])\r\n\t\t\t\t\t\tci++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t\tthrow new Error (\"postCallC: internal error A\");\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error (\"postCallC: internal error B\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cparams;\r\n\t}\r\n\r\n\t/*********************************************************************/\r\n\t/*********************************************************************/\r\n\r\n\t// copy a string into existing buffer in the webassembly module memory\r\n\tcopyString(buffer:number, buffer_size:number, sin:string):void {\r\n\t\tlet i;\r\n\t\tfor (i=0; i<sin.length && i<buffer_size-1; i++)\r\n\t\t\tthis.mem8[buffer+i]=sin.charCodeAt(i);\r\n\r\n\t\tthis.mem8[buffer+i]=0;\r\n\t}\r\n\r\n\t// allocate and copy a string into the webassembly module memory\r\n\tasync putString(sin:string) {\r\n\t\tlet strIndex:number=await this.malloc(sin.length);\r\n\t\tthis.copyString(strIndex, sin.length, sin);\r\n\t\treturn strIndex;\r\n\t}\r\n\r\n\tasync putU8(u8a:Uint8Array) {\r\n\t\tlet dest:number=await this.malloc(u8a.length); \r\n\t\tfor (let i=0; i<u8a.length; i++)\r\n\t\t\tthis.mem8[dest+i]=u8a[i];\r\n\r\n\t\treturn dest;\r\n\t}\r\n\r\n\tasync putArrayBuffer(ab:ArrayBuffer) {\r\n\t\tconst u8=new Uint8Array(ab);\r\n\t\treturn this.putU8(u8);\r\n\t}\r\n\r\n\t// given a url, load its contents, and stuff into wasm memory similar to Unint8Array\r\n\tasync fetchAndPutURL(fnin:URL) {\r\n\r\n\t\tif (!(typeof fnin === 'object' && fnin instanceof URL))\r\n\t\t\tthrow new Error(\"fetchAndPutURL param must be URL\");\r\n\r\n\t\ttry {\r\n\t\t\tlet response=await fetch(fnin);\r\n\t\t\tlet buffer = await response.arrayBuffer();\r\n\t\t\tlet src = new Uint8Array(buffer);\r\n\t\t\tlet dest=await this.putU8(src);\r\n\t\t\treturn [dest, src.length];\r\n\t\t\t\r\n\t\t} catch(err:any) {\r\n\t\t\tconsole.log('fetchAndPutURL Error. URL: '+fnin+'\\n' + err + (err.stack ? \"\\n\" + err.stack : ''));\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\tgetLong(idx:number): number {\r\n\t\tconst idx32=Math.floor(idx/4);\r\n\t\tif (idx32*4!=idx) throw new Error(\"getLong passed non long aligned address\")\r\n\t\tif (idx32<0 || idx32 >= this.mem32.length) throw new Error(\"invalid index passed to getLong: \"+idx+\", this.mem32.length: \"+this.mem32.length);\r\n\t\tconst long:number = this.mem32[idx32];\r\n\t\treturn long;\r\n\t}\r\n\t\r\n\tsetLong(idx:number, value:number) {\r\n        const idx32 = Math.floor(idx / 4);\r\n        if (idx32 * 4 != idx)\r\n            throw new Error(\"setLong passed non long aligned address\");\r\n        if (idx32 < 0 || idx32 >= this.mem32.length)\r\n            throw new Error(\"invalid index passed to setLong: \" + idx + \", this.mem32.length: \" + this.mem32.length);\r\n        this.mem32[idx32]=value;\r\n    }\r\n\r\n\tgetDouble(idx:number): number {\r\n\t\tconst idx64=Math.floor(idx/8);\r\n\t\tif (idx64*8!=idx) throw new Error(\"getLong passed non Float64 aligned address\")\r\n\t\tconst long:number = this.memD[idx64];\r\n\t\treturn long;\r\n\t}\r\n\r\n\tsetDouble(idx:number, value:number) {\r\n\t\tconst idx64=Math.floor(idx/8);\r\n\t\tif (idx64*8!=idx) throw new Error(\"setDouble passed non Float64 aligned address\")\r\n\t\tthis.memD[idx64]=value;\r\n\t}\r\n\r\n\tgetShort(idx:number): number {\r\n\t\tif (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getShort: \"+idx);\r\n\t\tconst short:number = this.mem8[idx]+this.mem8[idx+1]*256;\r\n\t\treturn short;\r\n\t}\r\n\r\n\t// get a string out of module memory\r\n\t// null terminated, up until max of (optional) len\r\n\tgetString(strIndex:number, len?:number): string {\r\n\t\tlet sout=\"\";\r\n\r\n\t\tlet i=0;\r\n\t\twhile (this.mem8[strIndex+i] && (len===undefined?true:i<len) && (strIndex+i) < this.mem8.length) {\r\n\t\t\tsout=sout+String.fromCharCode(this.mem8[strIndex+i]);\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn sout;\r\n\t}\r\n\r\n\t// get a byte array out of module memory when passed in index to [size, dataptr]\r\n\tgetU8Arr(idx:number): Uint8Array {\r\n\t\tif (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getU8: \"+idx);\r\n\r\n\t\tconst rv = new Uint32Array( (this.mem8.slice(idx, idx+8)).buffer );\r\n\t\tlet size:number=rv[0];\r\n\t\tlet dataptr:number=rv[1];\r\n\r\n\t\tif (dataptr <0 || dataptr >= (this.mem8.length)) throw new Error(\"invalid idx.dataptr passed to getU8\")\r\n\t\tif (size <0 || size > (this.mem8.length-dataptr)) throw new Error(\"invalid idx.size passed to  getU8\")\r\n\r\n\t\tconst u8=this.mem8.slice(dataptr, dataptr+size);\r\n\t\treturn u8;\r\n\t}\r\n\r\n\t// get a int32 array out of module memory when passed in index to [size, dataptr]\r\n\tgetU32Arr(idx:number): Uint32Array {\r\n\t\tif (idx<0 || idx>= this.mem8.length) throw new Error(\"invalid index passed to getU32: \"+idx);\r\n\r\n\t\tconst rv = new Uint32Array( (this.mem8.slice(idx, idx+8)).buffer );\r\n\t\tlet size:number=rv[0];\r\n\t\tlet dataptr:number=rv[1];\r\n\r\n\t\tif (dataptr <0 || dataptr >= (this.mem8.length)) throw new Error(\"invalid idx.dataptr passed to getU32\")\r\n\t\tif (size <0 || size > (this.mem8.length-dataptr)) throw new Error(\"invalid idx.size passed to  getU32\")\r\n\r\n\t\tif (size%4!=0) throw new Error(\"idx.size is not an integer number of 32 bit words\");\r\n\r\n\t\tconst u32 = new Uint32Array( (this.mem8.slice(dataptr, dataptr+size)).buffer );\r\n\t\treturn u32;\r\n\t}\r\n}\r\n","export class twrFloatUtil {\n    mod;\n    constructor(mod) {\n        this.mod = mod;\n    }\n    atod(strptr) {\n        const str = this.mod.getString(strptr);\n        const upper = str.trimStart().toUpperCase();\n        if (upper == \"INF\" || upper == \"+INF\")\n            return Number.POSITIVE_INFINITY;\n        else if (upper == \"-INF\")\n            return Number.NEGATIVE_INFINITY;\n        else {\n            // allow D for exponent -- old microsoft format they still support in fctv and I support in my awbasic\n            const r = Number.parseFloat(str.replaceAll('D', 'e').replaceAll('d', 'e'));\n            return r;\n        }\n    }\n    dtoa(buffer, buffer_size, value, max_precision) {\n        if (max_precision == -1) {\n            const r = value.toString();\n            this.mod.copyString(buffer, buffer_size, r);\n        }\n        else {\n            let r = value.toString();\n            if (r.length > max_precision)\n                r = value.toPrecision(max_precision);\n            this.mod.copyString(buffer, buffer_size, r);\n        }\n    }\n    toFixed(buffer, buffer_size, value, decdigits) {\n        const r = value.toFixed(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n    toExponential(buffer, buffer_size, value, decdigits) {\n        const r = value.toExponential(decdigits);\n        this.mod.copyString(buffer, buffer_size, r);\n    }\n    // emulates the C lib function -fcvt_s, but doesn't support all ranges of number.\n    // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\n    // Negative exponents must be now smaller than 1e-99\n    // fully-function C version also int he source, but this is the version enabled by default\n    fcvtS(buffer, // char *\n    sizeInBytes, //size_t\n    value, // double\n    fracpart_numdigits, //int\n    dec, // int *\n    sign // int *\n    ) {\n        if (buffer == 0 || sign == 0 || dec == 0 || sizeInBytes < 1)\n            return 1;\n        let digits;\n        let decpos;\n        let s = 0; // default to positive\n        if (Number.isNaN(value)) { /* nan */\n            digits = \"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        }\n        else if (!Number.isFinite(value)) { /* infinity */\n            digits = \"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits + 1);\n            decpos = 1;\n        }\n        else if (value == 0) {\n            digits = \"000000000000000000000000000000000000\".slice(0, fracpart_numdigits);\n            decpos = 0;\n        }\n        else {\n            if (value < 0) {\n                s = 1; // negative\n                value = Math.abs(value);\n            }\n            if (fracpart_numdigits > 100 || value > 1e+21 || value < 1e-99) {\n                this.mod.copyString(buffer, sizeInBytes, \"\");\n                this.mod.mem32[dec] = 0;\n                return 1;\n            }\n            const roundValStr = value.toFixed(fracpart_numdigits);\n            let [intPart = \"\", fracPart = \"\"] = roundValStr.split('.');\n            if (intPart == \"0\")\n                intPart = \"\";\n            if (intPart.length > 0) { // has integer part\n                decpos = intPart.length;\n                digits = intPart + fracPart;\n            }\n            else { // only a fraction\n                digits = fracPart.replace(/^0+/, \"\"); // remove leading zeros\n                decpos = digits.length - fracPart.length;\n            }\n        }\n        if (sizeInBytes - 1 < digits.length)\n            return 1;\n        this.mod.copyString(buffer, sizeInBytes, digits);\n        this.mod.setLong(dec, decpos);\n        this.mod.setLong(sign, s);\n        return 0;\n        /*\n        this version 'works' with larger numbers than using toFixed, but doesn't round correctly\n\n        let decpos=0;\n        let digits:string;\n        if (value!=0) decpos=Math.floor(Math.log10(value))+1;\n    \n        if (decpos>0) { // has integer part\n            const intlen=Math.max(decpos, 0);\n            console.log(\"intlen=\",intlen, \"decpos=\",decpos);\n            const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\n            digits=nonExponent.replace('.', '');\n            digits=digits.replace(/^0+/,\"\");  // remove leading zeros\n        }\n        else { // only a fraction\n            const intpart=Math.trunc(value);\n            const fracpart=value-intpart;\n            const prec=fracpart_numdigits- (-decpos);\n            console.log(\"prec=\",prec);\n            if (prec<1) {\n                digits=\"\";\n            }\n            else {\n                const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\n                digits=nonExponent.replace('.', '');\n                digits=digits.replace(/^0+/,\"\");\n            }\n        }\n\n        console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\n        console.log('digits=',digits);\n        console.log('dec=',decpos);\n        console.log(\"sign=\",s);\n    */\n    }\n}\n//# sourceMappingURL=twrfloat.js.map","\r\nimport {twrWasmModuleBase} from \"./twrmodbase.js\"\r\n\r\nexport class twrFloatUtil {\r\n    mod: twrWasmModuleBase;\r\n\r\n    constructor(mod: twrWasmModuleBase) {\r\n        this.mod=mod;\r\n    }\r\n\r\n    atod(strptr:number):number {\r\n        const str=this.mod.getString(strptr);\r\n\r\n        const upper=str.trimStart().toUpperCase();\r\n        if (upper==\"INF\" || upper==\"+INF\")\r\n            return Number.POSITIVE_INFINITY;\r\n        else if (upper==\"-INF\")\r\n            return Number.NEGATIVE_INFINITY\r\n        else {\r\n            // allow D for exponent -- old microsoft format they still support in fctv and I support in my awbasic\r\n            const r=Number.parseFloat(str.replaceAll('D','e').replaceAll('d','e'));\r\n            return r;\r\n        }\r\n    }\r\n\r\n    dtoa(buffer:number, buffer_size:number, value:number, max_precision:number):void {\r\n        if (max_precision==-1) {\r\n            const r=value.toString();\r\n            this.mod.copyString(buffer, buffer_size, r);\r\n        }\r\n        else {\r\n            let r=value.toString();\r\n            if (r.length>max_precision)\r\n                r=value.toPrecision(max_precision);\r\n            this.mod.copyString(buffer, buffer_size, r);\r\n        }\r\n    }\r\n\r\n    toFixed(buffer:number, buffer_size:number, value:number, decdigits:number):void {\r\n        const r=value.toFixed(decdigits);\r\n        this.mod.copyString(buffer, buffer_size, r);\r\n    }\r\n\r\n    toExponential(buffer:number, buffer_size:number, value:number, decdigits:number):void {\r\n        const r=value.toExponential(decdigits);\r\n        this.mod.copyString(buffer, buffer_size, r);\r\n    }\r\n\r\n    // emulates the C lib function -fcvt_s, but doesn't support all ranges of number.\r\n    // Number.toFixed() has a max size of 100 fractional digits,  and values must be less than 1e+21\r\n    // Negative exponents must be now smaller than 1e-99\r\n    // fully-function C version also int he source, but this is the version enabled by default\r\n    fcvtS(\r\n        buffer:number,  // char *\r\n        sizeInBytes:number, //size_t\r\n        value:number,  // double\r\n        fracpart_numdigits:number,  //int\r\n        dec:number,  // int *\r\n        sign:number  // int *\r\n     ):number {\r\n\r\n        if (buffer==0 ||sign==0 || dec==0 || sizeInBytes<1) return 1;\r\n\r\n        let digits:string;\r\n        let decpos:number;\r\n        let s=0; // default to positive\r\n\r\n\r\n        if (Number.isNaN(value))  { /* nan */\r\n            digits=\"1#QNAN00000000000000000000000000000\".slice(0, fracpart_numdigits+1);\r\n            decpos=1;\r\n        }\r\n        else if (!Number.isFinite(value)) {    /* infinity */\r\n            digits=\"1#INF00000000000000000000000000000\".slice(0, fracpart_numdigits+1);\r\n            decpos=1;\r\n        }\r\n        else if (value==0) {  \r\n            digits=\"000000000000000000000000000000000000\".slice(0,fracpart_numdigits);\r\n            decpos=0;\r\n        }\r\n        \r\n        else {\r\n\r\n            if (value<0) {\r\n                s=1;  // negative\r\n                value=Math.abs(value);\r\n            }\r\n\r\n            if (fracpart_numdigits>100 || value > 1e+21 || value < 1e-99) {  \r\n                this.mod.copyString(buffer, sizeInBytes, \"\");\r\n                this.mod.mem32[dec]=0;\r\n                return 1;\r\n            }\r\n\r\n            const roundValStr=value.toFixed(fracpart_numdigits);\r\n            let [intPart=\"\", fracPart=\"\"] = roundValStr.split('.');\r\n            if (intPart==\"0\") intPart=\"\";\r\n\r\n            if (intPart.length>0) { // has integer part\r\n                decpos=intPart.length;\r\n                digits=intPart+fracPart;\r\n            }\r\n            else { // only a fraction\r\n                digits=fracPart.replace(/^0+/,\"\");  // remove leading zeros\r\n                decpos=digits.length-fracPart.length;\r\n            }\r\n        }\r\n\r\n        if (sizeInBytes-1 < digits.length) return 1; \r\n        this.mod.copyString(buffer, sizeInBytes, digits);\r\n        this.mod.setLong(dec, decpos);\r\n        this.mod.setLong(sign, s);\r\n\r\n        return 0;\r\n\r\n        /*\r\n        this version 'works' with larger numbers than using toFixed, but doesn't round correctly\r\n\r\n        let decpos=0;\r\n        let digits:string;\r\n        if (value!=0) decpos=Math.floor(Math.log10(value))+1;\r\n    \r\n        if (decpos>0) { // has integer part\r\n            const intlen=Math.max(decpos, 0);\r\n            console.log(\"intlen=\",intlen, \"decpos=\",decpos);\r\n            const [nonExponent, exponent=0] = value.toPrecision(intlen+fracpart_numdigits).split('e');\r\n            digits=nonExponent.replace('.', '');\r\n            digits=digits.replace(/^0+/,\"\");  // remove leading zeros\r\n        }\r\n        else { // only a fraction\r\n            const intpart=Math.trunc(value);\r\n            const fracpart=value-intpart;\r\n            const prec=fracpart_numdigits- (-decpos);\r\n            console.log(\"prec=\",prec);\r\n            if (prec<1) {\r\n                digits=\"\";\r\n            }\r\n            else {\r\n                const [nonExponent, exponent=0] = fracpart.toPrecision(prec).split('e');\r\n                digits=nonExponent.replace('.', '');\r\n                digits=digits.replace(/^0+/,\"\");\r\n            }\r\n        }\r\n\r\n        console.log(\"fcvtS value\",value,\"fracpart_numdigits\",fracpart_numdigits);\r\n        console.log('digits=',digits);\r\n        console.log('dec=',decpos);\r\n        console.log(\"sign=\",s);\r\n    */\r\n\r\n\r\n    }\r\n}","import { twrSignal } from \"./twrsignal.js\";\nimport { twrTimeImpl } from \"./twrdate.js\";\n// This class is used in the  Main JS thread \nexport class twrWaitingCalls {\n    callCompleteSignal;\n    parameters;\n    constructor() {\n        this.callCompleteSignal = new twrSignal();\n        this.parameters = new Uint32Array(new SharedArrayBuffer(4));\n    }\n    startSleep(ms) {\n        setTimeout(() => {\n            this.callCompleteSignal.signal();\n        }, ms);\n    }\n    time() {\n        const ms = twrTimeImpl();\n        this.parameters[0] = ms;\n        this.callCompleteSignal.signal();\n    }\n    getProxyParams() {\n        return [this.callCompleteSignal.sharedArray, this.parameters.buffer];\n    }\n    processMessage(msgType, data) {\n        switch (msgType) {\n            case \"sleep\":\n                const [ms] = data;\n                this.startSleep(ms);\n                break;\n            case \"time\":\n                this.time();\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n}\n// This class is used in the worker thread \nexport class twrWaitingCallsProxy {\n    callCompleteSignal;\n    parameters;\n    constructor(params) {\n        this.callCompleteSignal = new twrSignal(params[0]);\n        this.parameters = new Uint32Array(params[1]);\n    }\n    sleep(ms) {\n        this.callCompleteSignal.reset();\n        postMessage([\"sleep\", [ms]]);\n        this.callCompleteSignal.wait();\n    }\n    time() {\n        this.callCompleteSignal.reset();\n        postMessage([\"time\"]);\n        this.callCompleteSignal.wait();\n        return this.parameters[0];\n    }\n}\n//# sourceMappingURL=twrwaitingcalls.js.map","import { twrSignal } from \"./twrsignal.js\";\r\nimport {twrTimeImpl} from \"./twrdate.js\"\r\n\r\n// These classes are used to proxy a call across the worker thread - main thread boundary and wait for the result\r\n\r\nexport type TWaitingCallsProxyParams = [SharedArrayBuffer, SharedArrayBuffer];   // twrSignal, parameters \r\n\r\n// This class is used in the  Main JS thread \r\nexport class twrWaitingCalls {\r\n\tcallCompleteSignal:twrSignal;\r\n\tparameters:Uint32Array;\r\n\r\n\tconstructor() {\r\n\t\tthis.callCompleteSignal=new twrSignal();\r\n\t\tthis.parameters=new Uint32Array(new SharedArrayBuffer(4));\r\n\t}\r\n\r\n\tprivate startSleep(ms:number) {\r\n\r\n\t\tsetTimeout(()=>{\r\n\t\t\tthis.callCompleteSignal.signal();\r\n\t\t}, ms);\r\n\t\t\r\n\t}\r\n\r\n\tprivate time() {\r\n\t\tconst ms=twrTimeImpl();\r\n\t\tthis.parameters[0]=ms;\r\n\t\tthis.callCompleteSignal.signal();\r\n\t}\r\n\r\n\tgetProxyParams():TWaitingCallsProxyParams {\r\n\t\treturn [this.callCompleteSignal.sharedArray, this.parameters.buffer as SharedArrayBuffer];\t\r\n\t}\r\n\r\n\tprocessMessage(msgType:string, data:any[]):boolean {\r\n\t\tswitch (msgType) {\r\n\t\t\tcase \"sleep\":\r\n\t\t\t\tconst [ms] =  data;\r\n\t\t\t\tthis.startSleep(ms);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"time\":\r\n\t\t\t\tthis.time();\r\n\t\t\t\tbreak;\r\n\t\t\t\r\n\t\t\tdefault:\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n// This class is used in the worker thread \r\nexport class twrWaitingCallsProxy {\r\n\tcallCompleteSignal:twrSignal;\r\n\tparameters:Uint32Array;\r\n\r\n\tconstructor(params:TWaitingCallsProxyParams) {\r\n\t\tthis.callCompleteSignal=new twrSignal(params[0]);\r\n\t\tthis.parameters=new Uint32Array(params[1]);\r\n\t}\r\n\r\n\tsleep(ms:number) {\r\n\t\tthis.callCompleteSignal.reset();\r\n\t\tpostMessage([\"sleep\", [ms]]);\r\n\t\tthis.callCompleteSignal.wait();\r\n\t}\r\n\r\n\ttime() {\r\n\t\tthis.callCompleteSignal.reset();\r\n\t\tpostMessage([\"time\"]);\r\n\t\tthis.callCompleteSignal.wait();\r\n\t\treturn this.parameters[0];\r\n\t}\r\n\r\n}\r\n","export function twrTimeImpl() {\n    return Date.now();\n}\n//# sourceMappingURL=twrdate.js.map","\r\nexport function twrTimeImpl() {\r\n\r\n    return Date.now();\r\n\r\n}"],"names":[],"version":3,"file":"twrmodworker.dfe73fd0.js.map"}