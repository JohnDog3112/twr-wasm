
add buffer size to io_gets()
double check "C_Cpp.default.defines": is correct location in workspace file. is it needed in makefile? can it be moved to vscode
enhance mod warning of function not in export table to tell user to use --export=stdio_canvas
add twr_getkey() as well as existing twr_getchar().

twrDiv vs twrCanvas cursor management discrepancies
   - io_putc will call twrDiv::charOut(), which used block cursor and will enable focus on the div when curor enabled
   - io_putc uses its internal default implementation ofr twr::Canvas, which uses underscore as cursor and can't set the canvas focus
   - io_putc logic doesn't seem right - it assumes if io->charout.io_putc not set, the console is windowed, and if 
      io->charout.io_putc is set, it just sort of punts for windowed?  
change canvas.getAvgCharWidth() to just getCharWidth (fixed width font)
struct IoConsole* twr_wasm_get_windowcon();  should this be renamed - create? Need to clarify how it interacts with navas
rename struct IoConsole * twr_get_stdio_con(); to twr_wasm style...?
fix +1 basic hack in twrmod
using shared:true in webassembly.Memory, even when shared mem not needed (twrWasModule).  
using --shared-memory in make file.  what it does is a bit murky .  Causes wasm-validate to generate an error
change my examples to all use one (the same) makefile
check malloc alignment. It is 4 byte aligned.  GNU is 8 or 16.   Can i detect wasm 64 or 32 bit runtime mode?  see alignof(max_align_t));
validate canvas.drawSeq   in non Async mod (due to call to Atomics.wait)  Seems to work.
in example, for dev,  use "npm link ../../" to avoid having to re-publish & install the tiny-wasm-runtime package
not sure why "W" of "Hello World" in stdio-canvas example looks funny
add twrDivInkey?  Its mostly implemented
modify maze back/fore color to get from canvas props
heap size is hard coded -- should use all avail heap #define HEAP_SIZE_IN_WORDS 50000
change twr_print's inside malloc/free to some kind of debug print
make these parameters: webAssembly.Memory - initial: 10, maximum:100,
add twrWaitingCalls.handleMessages() and like classes
add note in docs about URL param to loadWasm (index.html doesn't use new URL but maze-script ts does)
add an example that shows how to call back into javascript from C
should i do a react example?
create smaller version of twr.a w/o float
need better overflow detection? see square example, enter very large number
d2d - set default font as current font


https://daniel-hug.github.io/characters/#k_70

https://depth-first.com/articles/2020/01/13/first-steps-in-webassembly-hello-world/

https://ddr0.ca/blog-posts/13.Shared_Array_Buffers_With_WASM

https://blog.scottlogic.com/2019/07/15/multithreaded-webassembly.html

in the npm package
   add source?


post on using C code
https://stackoverflow.com/questions/53142710/howto-notify-npm-of-dependency-on-native-c-library


typescript module resolution (idea: i could require typescript and not provide lib-js ?)
classic: Use the classic module resolution strategy.
node: Use the node module resolution strategy.
You can also configure the base directory used to resolve non-relative module

From Makefile dev:

# The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.
# What is commonly known as the LLVM bitcode file format (also, sometimes anachronistically known as bytecode)
# is actually two things: a bitstream container format and an encoding of LLVM IR into the container format.
# llvm-link takes several LLVM bitcode files and links them together into a single LLVM bitcode file.
# The llc command compiles LLVM source inputs into assembly language for a specified architecture
# llc doc - The choice of architecture for the output assembly code is automatically determined from the input file
# The -cc1 argument indicates that the compiler front-end is to be used, and not the gcc driver. 

#out/awbasic.wasm: glue.c
#	clang -cc1 -emit-llvm-bc -triple=wasm32-unknown-unknown-wasm -std=c11  glue.c -o out/glue.bc                
#	llvm-link -o out/wasm.bc out/glue.bc
#	llc -O3 -filetype=obj out/wasm.bc -o out/glue.o
#	wasm-ld out/glue.o -o out/awbasic.wasm  --no-entry --allow-undefined  --import-memory --export=glue --export=get_heap_base

#
# build command line executable
#

#	-resource-dir C:/msys64/ucrt64/lib/clang/17 \
#	-internal-isystem C:/msys64/ucrt64/lib/clang/17/include \

#	-internal-isystem ../lib-twr/std-crt-include \


# why doesnt -fno-exceptions or -fno-trappping-math work? probalby because using -cc1

# below also works with link line updated to just use wasm-ld
#CFLAGS =  --target=wasm32-unknown-unknown-wasm -std=c17 -g -Wall -c -v \

# below does not produce an output.  It seems --allow-undefined symbols is required
#	wasm-ld $(OBJOUTDIR)/wasm.o -o $(OBJOUTDIR)/awbasic.wasm  -v --no-entry --warn-unresolved-symbols --import-undefined --import-memory --export=run_basic_file  --export=twr_capi_malloc


# i found this useful to look at symbols
# llc -filetype=asm wasm.bc -o wasm.asm
# other good tools: wasm-decompile, wasm-validate, llvm-objdump -S
# and wasm2wat awbasic.wasm -o aw.asm